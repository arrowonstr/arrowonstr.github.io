{"meta":{"title":"弦上的箭","subtitle":"","description":"我是即将到来的日子","author":"弦上的箭","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"K210开发板(五)—拍摄和KEYPAD照片查看","slug":"K210开发板-五-—拍摄和KEYPAD照片查看","date":"2023-09-18T16:16:58.000Z","updated":"2023-09-18T16:17:44.135Z","comments":true,"path":"2023/09/19/K210开发板-五-—拍摄和KEYPAD照片查看/","link":"","permalink":"http://example.com/2023/09/19/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%BA%94-%E2%80%94%E6%8B%8D%E6%91%84%E5%92%8CKEYPAD%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为实现拍摄和照片查看功能，摄像头实时将画面传到LCD上，按下BOOT拍照记录当前照片，按下KEYPAD进入照片查看，左滚KEYPAD查看上一张照片，右滚KEYPAD查看下一张照片，再次按下KEYPAD退出照片查看，重新恢复摄像功能。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.函数介绍1.1 lcd_draw_picture&emsp;&emsp;设置GPIO中断触发模式 参数成员 描述 输入输出 x 起始坐标 输入 y 起始坐标 输入 width 图像宽度 输入 height 图像长度 输入 *ptr 图像数据存放地址 输入 二.实验步骤1.配置&emsp;&emsp;过多了，这里就不贴了，见参考资料摄像头显示实验、按键中断实验、keypad控制RGB灯实验 2.初始化见参考文件就行，注意引脚定义不要冲突了 3.主体3.1 中断回调函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//button中断函数/*uint32_t phoNum=0;uint32_t g_count=-1;uint32_t *keyptrs[5]=&#123;NULL,NULL,NULL,NULL,NULL&#125;;uint32_t keyptr_addrs[5]=&#123;&#125;;*/int key_irq_cb(void* ctx)&#123; phoNum++; //照片数量 uint32_t *tmp = (uint32_t *)(ctx); //button使用次数 (*tmp)++; if(*tmp&lt;5)&#123; //存五张照片 uint32_t * keyptr=keyptrs[phoNum-1]; keyptr=(uint32_t*)iomem_malloc(CAM_WIDTH_PIXEL * CAM_HIGHT_PIXEL * 2); uint32_t *display_buf=display_buf_addr; for(int i=0;i&lt;76800;i++)&#123; *(keyptr+i)=*(display_buf+i); //写入数据 &#125; uint32_t keyptr_addr=keyptr; keyptr_addrs[phoNum-1]=keyptr_addr; //存放照片地址 lcd_draw_picture(0, 0, 320, 240,keyptr_addr); //拍摄显示 sleep(1); &#125;else&#123; printf(&quot;Photo space is full\\n&quot;); &#125; return 0;&#125;//keypad中断函数/*uint32_t keypad_idx=1; //当前照片索引//是否处于中断标志uint32_t keypad_left_icf_flag=0;uint32_t keypad_middle_icf_flag=0;uint32_t keypad_right_icf_flag=0;*///左滚动中断int keypad_left_icf(void* ctx)&#123; msleep(10); //消抖 keypad_left_icf_flag++; //使用中断 if(keypad_left_icf_flag&gt;1)&#123; //退出其它中断 keypad_left_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_left = gpiohs_get_pin(KEYPAD_LEFT_GPIONUM); if(state_keypad_left!=0)&#123; keypad_left_icf_flag=0; return 0; &#125;; //检查 if(keypad_left_icf_flag&gt;1)&#123; keypad_left_icf_flag--; return 0; &#125; uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;Enter keypad left interrupt%d\\n&quot;,keypad_left_icf_flag); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else if((*tmp)==1)&#123; printf(&quot;This is currently the first photo, there are no more previous photos available\\n&quot;); &#125;else&#123; (*tmp)--; &#125; keypad_left_icf_flag=0; //释放中断 return 0;&#125;//右滚动中断int keypad_right_icf(void* ctx)&#123; msleep(10); keypad_right_icf_flag++; //使用中断 if(keypad_right_icf_flag&gt;1)&#123; //退出其它中断 keypad_right_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_right = gpiohs_get_pin(KEYPAD_RIGHT_GPIONUM); if(state_keypad_right!=0)&#123; keypad_right_icf_flag=0; return 0; &#125;; //检查 uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;Enter keypad right interrupt\\n&quot;); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else if((*tmp)==phoNum)&#123; printf(&quot;This is currently the last photo, there are no further photos available\\n&quot;); &#125;else&#123; (*tmp)++; &#125; keypad_right_icf_flag=0; //释放中断 return 0;&#125;//keypad中键中断int keypad_middle_icf(void* ctx)&#123; msleep(10); keypad_middle_icf_flag++; if(keypad_middle_icf_flag&gt;1)&#123; keypad_middle_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_middle = gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM); if(state_keypad_middle!=0)&#123; keypad_middle_icf_flag--; return 0; &#125;; //检查 uint32_t *tmp = (uint32_t *)(ctx); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else&#123; printf(&quot;enter photo view\\n&quot;); while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)!=1); //等待此次按下结束 while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)==1)&#123; //等待下次按下离开查看照片 lcd_draw_picture(0, 0, 320, 240, keyptr_addrs[keypad_idx-1]); &#125; &#125; while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)!=1); //防止离开时按下的按钮继续触发查看照片 keypad_middle_icf_flag--; printf(&quot;exit keypad_enter_mid_icf%d %d\\n&quot;,keypad_middle_icf_flag,keypad_middle_icf_exit_flag); return 0;&#125;//摄像头中断static int on_dvp_irq_cb(void *ctx)&#123; //读取DVP中断状态，如果完成则刷新显示地址的数据，并清除中断标志，否则读取摄像头数据 if (dvp_get_interrupt(DVP_STS_FRAME_FINISH)) &#123; dvp_set_display_addr((uint32_t)display_buf_addr); dvp_clear_interrupt(DVP_STS_FRAME_FINISH); g_dvp_finish_flag = 1; &#125; else &#123; if (g_dvp_finish_flag == 0) dvp_start_convert(); dvp_clear_interrupt(DVP_STS_FRAME_START); &#125; return 0;&#125; 3.2 while循环1234while (g_dvp_finish_flag == 0);g_dvp_finish_flag = 0;//显示画面lcd_draw_picture(0, 0, 320, 240, display_buf_addr); 三.实验总结遇到问题： KEYPAD相同中断函数同时触发两次，尽管用了互斥变量还是没能解决 LCD显示已经拍摄的照片时（除最后一张），显示花纹图像，未正确显示 LCD显示偶尔会黑屏、失真 终端中文乱码，打印出问题 KEYPAD中键检测不灵敏，需要按一小段时间才能检测到 解决方案： 未解决 未解决，估计和内存存放地址有关 Reset可解决，但原因未找明，仍会复发 改用英文，每行加回车 未解决 Tips:引脚过多，注意软件引脚定义，不要冲突 结语：&emsp;&emsp;第一次功能比较多的复合实验，遇到的冲突不少，需要注意不同功能间的交互、变量统一、冲突问题","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(四)—按键独立中断","slug":"K210开发板-四-—按键独立中断","date":"2023-09-17T10:20:11.000Z","updated":"2023-09-17T11:51:00.027Z","comments":true,"path":"2023/09/17/K210开发板-四-—按键独立中断/","link":"","permalink":"http://example.com/2023/09/17/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E5%9B%9B-%E2%80%94%E6%8C%89%E9%94%AE%E7%8B%AC%E7%AB%8B%E4%B8%AD%E6%96%AD/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为按键独立中断，按键未按下时播放音乐，按键按下时暂停播放。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.外部中断&emsp;&emsp;普通的按键的实验，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断的在实际项目的应用非常普遍。 2.按键原理&emsp;&emsp;BOOT 按键按下的时候会把电平拉低，松开的时候会把电平拉高，只需要检测 BOOT 按键的 IO 口的电平，如果是按下则会产生下降沿，松开会产生上升沿，以 此的方式来检测并触发系统的中断 3.函数介绍4.1 gpiohs_set_pin_edge&emsp;&emsp;设置GPIO中断触发模式 参数成员 描述 输入输出 pin GPIO管脚 输入 edge 中断触发方式 输入 4.2 gpiohs_irq_register&emsp;&emsp;设置GPIO中断回调函数 参数成员 描述 输入输出 pin GPIO管脚 输入 priority 中断优先级 输入 plic_irq_callback_t 中断回调函数 输入 *ctx 回调函数的形参 输入 二.实验步骤1.配置1.1 引脚12345678910111213141516171819202122//定义硬件引脚(见原理图)#define PIN_SPK_WS (30)#define PIN_SPK_DATA (31)#define PIN_SPK_BCK (32)#define PIN_KEY (16)//定义软件GPIO口#define KEY_GPIONUM (3)//将硬件引脚映射到软件GPIO功能#define FUNC_SPK_WS FUNC_I2S2_WS#define FUNC_SPK_DATA FUNC_I2S2_OUT_D0#define FUNC_SPK_BCK FUNC_I2S2_SCLK#define FUNC_KEY (FUNC_GPIOHS0 + KEY_GPIONUM)void hardware_init(void)&#123; fpioa_set_function(PIN_SPK_WS, FUNC_SPK_WS); fpioa_set_function(PIN_SPK_DATA, FUNC_SPK_DATA); fpioa_set_function(PIN_SPK_BCK, FUNC_SPK_BCK); fpioa_set_function(PIN_KEY, FUNC_KEY);&#125; 1.2 函数12345678int key_irq_cb(void* ctx)&#123; gpio_pin_value_t key_state = gpiohs_get_pin(KEY_GPIONUM); //这里只是为了测试才在中断回调打印数据，正常情况下是不建议这么做的 printf(&quot;IRQ The PIN is %d\\n&quot;, key_state); uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;count is %d\\n&quot;, (*tmp)++); return 0;&#125; 2.初始化123456789101112131415161718192021222324252627// 硬件引脚初始化hardware_init();//外部中断初始化plic_init();///使能全局中断sysctl_enable_irq();//设置系统时钟sysctl_pll_set_freq(SYSCTL_PLL0, 320000000UL);sysctl_pll_set_freq(SYSCTL_PLL1, 160000000UL);sysctl_pll_set_freq(SYSCTL_PLL2, 45158400UL);uarths_init();//初始化I2Si2s_init(I2S_DEVICE_2, I2S_TRANSMITTER, 0x03);i2s_tx_channel_config( I2S_DEVICE_2, // I2S设备号 I2S_CHANNEL_0, // I2S通道 RESOLUTION_16_BIT, // 接收数据位数 SCLK_CYCLES_32, // 单个数据时钟数 TRIGGER_LEVEL_4, // DMA触发时FIFO深度 RIGHT_JUSTIFYING_MODE); // 工作模式// 初始化按键key//设置按键的GPIO模式为上拉输入gpiohs_set_drive_mode(KEY_GPIONUM,GPIO_DM_INPUT_PULL_UP);//设置按键的GPIO电平触发模式为下降沿触发gpiohs_set_pin_edge(KEY_GPIONUM,GPIO_PE_RISING);//设置按键GPIO口的中断回调gpiohs_irq_register(KEY_GPIONUM,1,key_irq_cb,&amp;g_count); 3.主体123456789101112gpio_pin_value_t key_state = gpiohs_get_pin(KEY_GPIONUM);//检测按键是否未被按下if(key_state==1)&#123; i2s_play( I2S_DEVICE_2, // I2S设备号 DMAC_CHANNEL0, // DMA通道号 (uint8_t *)test_pcm, // 播放的PCM数据 sizeof(test_pcm), // PCM数据的长度 1024, // 单次发送数量 16, // 单次采样位宽 2); // 声道数 &#125; 三.实验总结遇到问题：音乐暂停没有实现真正意义上的暂停，松开按键只会重新播放解决方案：未解决，需要了解如何暂停I2S的传输然后恢复 结语：&emsp;&emsp;无","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(三)—扬声器播放","slug":"K210开发板-三-—扬声器播放","date":"2023-09-16T14:59:34.000Z","updated":"2023-09-17T11:50:55.044Z","comments":true,"path":"2023/09/16/K210开发板-三-—扬声器播放/","link":"","permalink":"http://example.com/2023/09/16/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%B8%89-%E2%80%94%E6%89%AC%E5%A3%B0%E5%99%A8%E6%92%AD%E6%94%BE/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为扬声器的播放。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.音频转化过程&emsp;&emsp;模拟量转成数字量过程，一般可以分为三个过程，分别为采样、量化、编码， 用一个比源声音频率高的采样信号去量化源声音，记录每个采样点的值， 最后如果把所有采样点数值连接起来与源声音曲线是互相吻合的，只是它不是连续的。 在图中两条蓝色虚线距离就是采样信号的周期，即对应一个采样频率(FS)， 可以想象得到采样频率越高最后得到的结果就与源声音越吻合，但此时采样数据量越越大， 一般使用44.1KHz采样频率即可得到高保真的声音。每条蓝色虚线长度决定着该时刻源声音的量化值， 该量化值有另外一个概念与之挂钩，就是量化位数。量化位数表示每个采样点用多少位表示数据范围， 常用有16bit、24bit或32bit，位数越高最后还原得到的音质越好，数据量也会越大。 2.I2SI2S 有 3 个主要信号： 串行时钟 SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK 都有 1 个脉冲。SCLK 的频率&#x3D;2×采样频率×采样位数 帧时钟 LRCK，用于切换左右声道的数据。LRCK 为“1”表示正在传输的 是左声道的数据，为“0”则表示正在传输的是右声道的数据。LRCK 的频率等于 采样频率。 串行数据 SDATA，就是用二进制补码表示的音频数据。 &emsp;&emsp;DAC 芯片将 I2S 信号转化成 RCH 信号输送给功放，功放将 RCH 信号发大，然 后扬声器播放出对应的声音。 3.PCM&emsp;&emsp;将每个数字化声音数据转换成二进制数据，该数据就是 PCM 数据。PCM 数据可以直接存储在介质上，也可以在经过编解码处理后进行存储或传输。 &emsp;&emsp;PCM 数据常用量化指标：采样率位深、声道数、采样数据是否有符号(有符号的采样数据不能使用无符号的方式播放)、字节序（表示 PCM 数据是用大端存储还是小端存储,通常是小端存储） &emsp;&emsp;对于 8-bit PCM 数据而言，存储结构可能是左声道数据右声道数据交替存储 &emsp;&emsp;PCM数据的音量调整由于数据溢出的可能性，不应当直接将数据*n，可通过对数变换处理x * tan(x&#x2F;n)达到调整音量的效果 4.函数介绍4.1 i2s_tx_channel_config&emsp;&emsp;设置I2S发送数据的通道参数 参数成员 描述 输入输出 device_num I2S号 输入 channel_num 通道号 输入 word_length 接收数据位数 输出 word_select_size 单个数据时钟数 输入 trigger_level DMA触发时FIFO深度 输入 word_mode 工作模式 输入 4.2 i2s_play&emsp;&emsp;发送 PCM 数据, 比如播放音乐 参数成员 描述 输入输出 device_num I2S号 输入 channel_num 通道号 输入 buf PCM PCM数据 输入 buf_len PCM数据长度 输入 frame 单次发送数量 输入 bits_per_sample 单次采样位宽 输入 track_num 声道数 输入 二.实验步骤1.配置1.1.头文件12//部分头文件#include &quot;pcm.h&quot; 头文件pcm.h包含了变量uint16_t test_pcm[]，其记录了要播放音频的PCM数据，参考资料直接给出了数据。这里我通过matlab将.wav文件转为PCM数据的方式实现播放任意音频。 12345678910%读取.wav文件filename=&#x27;name.wav&#x27;;[data,fs]=audioread(filename);data=data(:,2);%将数据归一化并转换为int16类型pcm_data=int16(data * (2^15 - 1));%将int16数据转换为uint16类型pcm_data=typecast(pcm_data, &#x27;uint16&#x27;);%将数据写入文件 以逗号分隔dlmwrite(&#x27;data.txt&#x27;,pcm_data,&#x27;delimiter&#x27;,&#x27;,&#x27;); Tips:由于C语言不支持数组元素用空格分开，所以数据需要用逗号分隔再复制到pcm.h中 1.2.引脚配置123456789101112131415161718//定义硬件引脚(见原理图)#define PIN_SPK_WS (30)#define PIN_SPK_DATA (31)#define PIN_SPK_BCK (32)//定义软件GPIO口/*FUNC_I2S2_WSFUNC_I2S2_OUT_D0FUNC_I2S2_SCLK*///将硬件引脚映射到软件GPIO功能#define FUNC_SPK_WS FUNC_I2S2_WS#define FUNC_SPK_DATA FUNC_I2S2_OUT_D0#define FUNC_SPK_BCK FUNC_I2S2_SCLKvoid hardware_init(void)&#123; fpioa_set_function(PIN_SPK_WS, FUNC_SPK_WS); fpioa_set_function(PIN_SPK_DATA, FUNC_SPK_DATA); fpioa_set_function(PIN_SPK_BCK, FUNC_SPK_BCK);&#125; 2.初始化1234567891011121314151617//硬件引脚初始化hardware_init();//设置系统时钟sysctl_pll_set_freq(SYSCTL_PLL0, 320000000UL);sysctl_pll_set_freq(SYSCTL_PLL1, 160000000UL);sysctl_pll_set_freq(SYSCTL_PLL2, 45158400UL);uarths_init();//初始化I2S，第三个参数为设置通道掩码，通道0:0x03,通道1：0x0C,通道2：0x30,通道3:0xC0i2s_init(I2S_DEVICE_2, I2S_TRANSMITTER, 0x03);//设置I2S发送数据的通道参数i2s_tx_channel_config( I2S_DEVICE_2, // I2S设备号 I2S_CHANNEL_0, // I2S通道 RESOLUTION_16_BIT, // 接收数据位数 SCLK_CYCLES_32, // 单个数据时钟数 TRIGGER_LEVEL_4, // DMA触发时FIFO深度 RIGHT_JUSTIFYING_MODE); // 工作模式 3.主体12345678i2s_play( I2S_DEVICE_2, //I2S设备号 DMAC_CHANNEL0, //DMA通道号 (uint8_t *)test_pcm, //播放的PCM数据 sizeof(test_pcm), //PCM数据的长度 1024, //单次发送数量 16, //单次采样位宽 2); //声道数 三.实验总结遇到问题：PCM数据的获取解决方案：见二.1.1 结语：&emsp;&emsp;仅仅按照参考资料的程序实验是不够的，需要自己理解代码的含义，做出可拓展的尝试","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(二)—点亮LED灯","slug":"K210开发板-二-—点亮LED灯","date":"2023-09-16T05:40:42.000Z","updated":"2023-09-16T15:02:42.420Z","comments":true,"path":"2023/09/16/K210开发板-二-—点亮LED灯/","link":"","permalink":"http://example.com/2023/09/16/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%BA%8C-%E2%80%94%E7%82%B9%E4%BA%AELED%E7%81%AF/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为LED灯的交替闪烁。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.GPIO&emsp;&emsp;我个人理解是将芯片的的操作封装成函数，使微控制器成为微处理器 好比你告诉家里的保姆说“去吧客厅的灯关上”，他就走过去按动灯的开关，然后灯就灭了。你下的这个指令的动作相当于调用了GPIO操作的函数，保姆去按开关这个动作相当于函数配置寄存器。 2.K210的GPIO—FPIOA&emsp;&emsp;FPIOA （现场可编程 IO 阵列）允许用户将 255 个内部功能映射到芯片外围的 48 个自由 IO 上 二.实验步骤1.配置1234567891011121314//定义硬件引脚(见原理图)#define PIN_LED_0 (0)#define PIN_LED_1 (17)//定义软件GPIO口#define LED0_GPIONUM (0)#define LED1_GPIONUM (1)//将硬件引脚映射到软件GPIO功能#define FUNC_LED0 (FUNC_GPIO0 + LED0_GPIONUM)#define FUNC_LED1 (FUNC_GPIO0 + LED1_GPIONUM)void hardware_init(void)&#123; fpioa_set_function(PIN_LED_0, FUNC_LED0); fpioa_set_function(PIN_LED_1, FUNC_LED1);&#125; 2.初始化123456789hardware_init(); //硬件引脚初始化gpio_init(); // 使能GPIO的时钟// 设置LED0和LED1的GPIO模式为输出gpio_set_drive_mode(LED0_GPIONUM, GPIO_DM_OUTPUT);gpio_set_drive_mode(LED1_GPIONUM, GPIO_DM_OUTPUT);// 先关闭LED0和LED1gpio_pin_value_t value = GPIO_PV_HIGH;gpio_set_pin(LED0_GPIONUM, value);gpio_set_pin(LED1_GPIONUM, value); 3.主体123sleep(1); //延时1sgpio_set_pin(LED0_GPIONUM, value); //设置引脚值gpio_set_pin(LED1_GPIONUM, value = !value); 三.实验总结遇到问题：未能理解FUNC_GPIO0的作用解决方案：暂未解决 结语：&emsp;&emsp;无","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(一)—搭建开发环境","slug":"K210开发板-一-—搭建开发环境","date":"2023-09-15T13:53:59.000Z","updated":"2023-09-16T13:27:42.216Z","comments":true,"path":"2023/09/15/K210开发板-一-—搭建开发环境/","link":"","permalink":"http://example.com/2023/09/15/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%B8%80-%E2%80%94%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为开发环境的搭建。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.安装串口驱动&emsp;&emsp;使用参考资料中的程序安装即可 遇到问题：设备管理器中找不到端口选项解决方案：点击 查看-&gt;显示隐藏的设备即可 Tips:连接开发板需要用数据线，连接仅能充电的线电脑是没有反应的 二.配置VSCode开发环境&emsp;&emsp;按照参考资料中的教程即可 创建新项目 把项目文件(包含main.c)复制到 SDK 中的src目录下 进入 build 目录，运行命令 cmake .. -DPROJ&#x3D;name -G “MinGW Makefiles” make 打开kfalsh把生成的.bin文件(填入路径)烧录到开发板上 遇到问题：解压参考资料里的toolchain时报错：路径太长无法复制解决方案：进入https://www.canaan-creative.com/developer 下载压缩包即可 结语：&emsp;&emsp;搭建过程友好，不要气馁","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(零)","slug":"K210开发板-零","date":"2023-09-15T10:44:02.000Z","updated":"2023-09-17T11:50:55.044Z","comments":true,"path":"2023/09/15/K210开发板-零/","link":"","permalink":"http://example.com/2023/09/15/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E9%9B%B6/","excerpt":"","text":"一.介绍&emsp;&emsp;本类博客categories:嵌入式-&gt;K210 tags:K210&emsp;&emsp;本类博客用于记录自己的K210开发板学习过程，由于参考资料的教程比较齐全，本类博客会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 二.本类博客风格 第一篇为开发环境的搭建，之后为记录程序实践，第一篇不适用于下述风格 二级标题必选为实验准备、实验步骤、实验总结 实验步骤中三级标题可选为代码编写、烧录结果 代码编写中四级标题可选为&emsp;&emsp;配置（main函数前部分）&emsp;&emsp;初始化（main函数至while循环部分&emsp;&emsp;主体（while循环中和中断回调函数中部分）&emsp;&emsp;其它（while循环后部分） 配置中五级标题可选为头文件、引脚、函数 主题中五级标题可选为while循环和中断回调函数","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2023-09-15T07:44:02.000Z","updated":"2023-09-16T13:27:42.216Z","comments":true,"path":"2023/09/15/我的第一篇博客/","link":"","permalink":"http://example.com/2023/09/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录自己的第一篇博客，主要内容为Hexo的主要指令和markdown的主要语法 一.Hexo主要指令 hexo -n “xxx” %创建一个新文章 hexo clean %清理 hexo -g %生成 hexo -s %预览 hexo -d %部署 %http://localhost:4000/ #本地访问地址%https://arrowonstr.github.io/ #查看博客 二.markdown主要语法 %n级标题 #*n %引用 &gt; %列表 - %代码块 &#96;&#96;&#96;代码语言 %脚注 [^] %横线 — %网址 [网站]（地址”注释”) %超链接 [标题](#标题） %图片 ！[图片](链接”注释”） %斜体 ** %加粗 ** ** %行内代码&#x2F;使符号不起格式作用 `` %下划线 &lt;u&gt;下划线&lt;/u&gt; %高亮 &#x3D;&#x3D; &#x3D;&#x3D; 结语：&emsp;&emsp;博客之旅由此开始","categories":[{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"我是即将到来的日子","slug":"我是即将到来的日子","date":"2023-09-15T07:00:00.000Z","updated":"2023-09-17T15:54:30.715Z","comments":true,"path":"2023/09/15/我是即将到来的日子/","link":"","permalink":"http://example.com/2023/09/15/%E6%88%91%E6%98%AF%E5%8D%B3%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%A5%E5%AD%90/","excerpt":"","text":"我的博客风格%日记类的博客可以不按照任意风格格式 1.博客框架 每篇博客使用tags归类 类内博客标题使用xxx(一)—xxx的格式 类内博客第一篇标题为xxx(零)，内容为：&emsp;&emsp;该类博客的主要介绍&emsp;&emsp;该类博客的风格 类内博客简介包含该类的主要介绍 类内博客最后一篇标题为xxx(END) tags包含”日记” 2.行文框架 行文第一块为简介：xxx 字体为灰色 行文第二块为参考资料 正文从二级标题开始 %一级标题为文章标题&emsp;&emsp;二级标题使用 一. 二. 三. …&emsp;&emsp;三级标题使用 1. 2. 3. …&emsp;&emsp;四级标题使用 1.1. 1.2. 1.3.&emsp;&emsp;以此类推… 建议在内容下添加&emsp;&emsp;遇到问题&amp;解决方案 颜色为#3399ff&emsp;&emsp;Tips 颜色为#ff6600 行文结尾为结语：xxx 颜色为灰色 3.其它 正文注释使用% 代码注释依据语言决定 &emsp;&emsp;早祷的钟声突然响了，无数的钟声一下子都惊醒了。天又黎明！黑沉沉的危崖后面，看不见的太阳在金色的天空升起。快要倒下来的克利斯朵夫终于到了彼岸。于是他对孩子说： &emsp;&emsp;“咱们到了！唉，你多重啊！孩子，你究竟是谁呢？” &emsp;&emsp;孩子回答说： &emsp;&emsp;“我是即将来到的日子。” ***","categories":[{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"嵌入式/K210","permalink":"http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"},{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"},{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]}