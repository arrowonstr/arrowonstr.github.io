{"meta":{"title":"弦上的箭","subtitle":"","description":"我是即将到来的日子","author":"弦上的箭","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"编译原理笔记","slug":"编译原理笔记","date":"2023-11-24T07:26:00.000Z","updated":"2023-11-28T09:08:49.011Z","comments":true,"path":"2023/11/24/编译原理笔记/","link":"","permalink":"http://example.com/2023/11/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简介：&emsp;&emsp; 一. 编译器概述1. 计算机语言面向机器语言：机器指令、汇编面向人类语言：通用程序设计语言、数据查询语言… 2. 语言之间的翻译2.1 翻译模式正向工作： 汇编语言-&gt;机器指令：汇编&#x2F;交叉汇编 高级语言-&gt;汇编语言&#x2F;机器指令：编译&#x2F;交叉编译 高级语言-&gt;高级语言：转换&#x2F;预编译&#x2F;预处理（如#include) 逆向工作： 反汇编&#x2F;反编译 2.2 翻译形态 2.2.1 编译器：先翻译后执行特点：工作效率高（时间快、空间省）、交互性与动态特性差、可移植性差功能：完成翻译 2.2.2 解释器：便翻译边执行特点：工作效率低（时间慢、空间费）、交互性与动态特性好、可移植性好功能：完成翻译 3. 编译器的构成与工作原理3.1 通用程序设计语言的主要成分基本抽象：过程（函数）、抽象数据类型、类定义方式：声明+操作组成部分：头+体（如函数头+函数体）（ 其中：体包括： 声明性语句 编译器生成相应环境（存储空间） 操作性语句 编译器生成可执行代码序列） 3.2 编译器的工作阶段 词法分析：识别记号（关键字（保留字）、标识符、字面量、特殊符号） 语法分析：识别语言结构，并以树的形式表示 语义分析：语义计算和处理。如考察结构正确的句子是否语义合法、修改树结构、查填符号表 中间代码生成（可选）：生成一种既接近目标语言，又与具体机器无关的表示，便于代码优化 中间代码优化（可选）：优化实际上是等价变换，变换前后功能完全相同，但空间时间上都更好 目标代码生成：不同形式的目标代码，如：汇编、可重定位的二进制代码、内存形式（Load and Go） 符号表管理：合理组织符号，便于各阶段查找、填写等 出错处理：词法错、语法错、静态语义错（x&#x2F;0)、动态语义错(x&#x2F;y，y在运行中可能为0) 3. 编译器的构造方法架构：分析（前端）-&gt;中间代码-&gt;综合（后端）构造方法： 直接使用汇编语言&#x2F;通用程序设计语言 利用编译器编写工具 基于编译器基础架构的编译器构造系统（开放式编译器，如GCC&#x2F;LLCM&#x2F;SUIF&#x2F;COINS） 二. 词法分析1. 基本概念 单词：被识别出的元素自身的值，也叫词值。类别：关键字：kw，如if while标识符：id，如变量名字面量：literal，如60特殊符号：ks，如&#x3D; + 模式：产生和识别单词（元素）的规则 记号：按照某个模式识别出的元素记号&#x3D;记号类别+记号属性 词法分析器：特征：唯一接触源程序的部分任务： （根据模式）识别记号，并交给语法分析器 过滤源程序无用成分，如注释、空格、回车 处理与具体平台有关的输入（如回车） 调用符号管理器或出错处理器 工作方式： 单独扫描一遍 作为语法分析器的子程序（需要时调用词法分析器） 并行（词法分析器生成记号流同时语法分析器处理） 2. 正规式2.1 语言与字符串在词法分析的角度，语言L是有限字母表上有限长度字符串的集合（语言是由记号组成的集合）字符串运算：集合运算： 2.2 正规式与正规集其中：正规式运算优先级从高到低为：闭包运算、连接运算、或运算 2.3 等价正规式若正规式P，Q表示同一正规集，则P和Q等价，记作P&#x3D;Q证明方法： 证明不同正规式表示的集合相同 根据正规式代数性质运算 2.3 简化正规式若r是表示L（r）的正规式，则 正闭包：r⁺=rr*=r*r,r*=r|ε 其中：*和⁺运算优先级相同 可缺省：r?=r|ε 其中：*和?运算优先级相同 串：&quot;r&quot;=r,ε=&quot;&quot; 可用于字符转义，如：“|”表示字符|而非或运算 字符组：r=[r&#39;] 其中：r是由若干字符进行或运算构成的正规式， r’有两种书写形式： 枚举：a|b|c|d&#x3D;[abcd] 分段：a|b|c|d&#x3D;[a-d] 非字符组：[^r]是表示∑-[r]的正规式 辅助定义：名字&#x3D;正规式 名字仅供正规式内部使用（类似于C语言中define） 2.4 正规式说明记号记号&#x3D;正规式如：relation &#x3D; &lt;|&gt;|&lt;&#x3D;|&gt;&#x3D;|&#x3D; 3. 不确定的 有限自动机（NFA）模式的识别&#x2F;正规集的描述：正规式记号的识别&#x2F;正规集的识别：有限自动机最大的特点：不确定性（即某一状态对于一个字符可能有多个状态转移） 3.1 定义NFA是一个五元组：M&#x3D;(S,∑,move,s0,F)其中： S：有限个状态的集合 ∑：有限个输入字符的集合 move：状态转移函数。 move(si,ch)&#x3D;sj表示当前状态si遇到输入字符ch转移到状态sj s0：唯一的初态（开始状态） F：终态集（接收状态集），它是S的子集，包含所有终态 3.2 表示方法 状态转换图：节点：代表NFA中每个状态边：代表NFA中的状态转移函数。连接两个状态，边上标记输入的字符 状态转移矩阵：行标：∑中的字符列标：S中的状态矩阵值：对应状态接受对应字符后转移到的状态集合 3.3 识别方法对于一个输入序列： 从NFA初态开始 对于输入的每个字符，寻找其下一个状态转移，直到到达一个终态，或没有下一个状态转移（根据最长匹配原则，要求所有字符都被输入） 如果此时处于终态，则NFA接受该序列 否则，回溯+试探：沿原路返回，对于每个状态寻找另一种可能的状态转移，若能到达终态，则NFA接受该序列，否则（一直返回到初态都不能到达终态）不接受 3.4 等价有限自动机若有限自动机M和M’识别同一正规集，则M和M’等价，记作M&#x3D;M’ 3.5 构造NFA使用Thompson算法，先将正规式分解，然后使用以下规则构造NFA： 4. 确定的有限自动机（DFA）由于DFA识别记号时需要尝试所有路径才能确定一个序列不被接受，且识别时要进行大量回溯，算法较为复杂，时间复杂度高，所以提出构建一种有限自动机，其在任一状态下遇到同一字符最多有一个状态转移 4.1 定义DFA是NFA的一个特例，其中 没有状态具有ε状态转移（即状态中没有标记ε的边） 对于每个状态和每个字符，最多有一个下一状态 4.2 构造DFA（确定化NFA）ε-闭包(T)：状态集T上的ε-闭包(T)代表从状态集T出发，经过ε（即不经过任何字符）可到达的状态全体，其构造方法为： （初始化）T中所有状态属于ε-闭包(T) （更新）将smove(ε-闭包(T),ε)中的状态添加进ε-闭包(T) 循环2，直到不能转移到任一其它状态 其中：smove(S,ch)代表对于S中的每个元素接受字符ch后能够到达的状态（move(item_in_S,ch)）的合集 子集法构造DFA输入：NFA，M&#x3D;(S,∑,move,s0,F)输出：DFA，DM&#x3D;(DS,D∑,Dmove,Ds0,DF) （初始化）初态Ds0为ε-闭包(s0)；令DS∪&#x3D;Ds0 对于DS中每个元素ds，∑中每个字符ch，计算得smove(ds,ch)&#x3D;new_ds；令DS∪&#x3D;ε-闭包(new_ds)，move+&#x3D;(move(ds,ch)&#x3D;ε-闭包(new_ds)) 循环2，直到DS中所有元素都被计算过 其中：D∑&#x3D;∑，终态DF为DS中包含终态F中元素的元素集合 例： 初态：求0的ε的闭包：经过任意条ε所能到达的状态，集合为{0,1,3,4,5,6,7,9}，将其填入表格第一行第一列 a b {0,1,3,4,5,6,7,9} {0,1,3,4,5,6,7,9}中：1接受a到达2，4接受a到达4，其余没有接受a到达某个状态，所以集合为{2,4}，其的ε-闭包为{2,4,6,7,9}，将其填入第一行第二列 {0,1,3,4,5,6,7,9}中：同2，接受b，最后得到集合{5,6,7,8,9}，将其填入第一行第第三列 a b {0,1,3,4,5,6,7,9} {2,4,6,7,9} {5,6,7,8,9} 观察{2,4,6,7,9}和{5,6,7,8,9}未在第一列出现，将他们填入第一列 a b {0,1,3,4,5,6,7,9} {2,4,6,7,9} {5,6,7,8,9} {2,4,6,7,9} {5,6,7,8,9} 同2，3对{2,4,6,7,9}和{5,6,7,8,9}计算，然后同4添加元素，再重复计算，最终得到表格，并对新的状态集重新编号： 根据状态表绘制状态图： 4.2 最小化DFA 可区分：对于状态s和t，若其中一个状态接受字符串w而另一个状态不接受，或者存在字符串w使得s和t接受后到达不同的状态，则s和t是可区分的 （不可区分：对于状态s和t，接受任意字符串到达的状态都是一样的，则s和t不可区分） 死状态：接受任意字符都转向其自身，且不是终态 不可达状态：从初态不可到达的状态 最小化算法对于DFA：D&#x3D;(S,∑,move,s0,F) 初始化分∏&#x3D;{S-F,F} 开始新一轮划分，对于两个状态s，t，若它们接受任意字符后到达的状态同属于∏中的某一个状态集合，则将它们划分至一个状态，否则它们就是不同的状态。 遍历每个状态（不包括∏中不可再划分的状态集合中的元素），应用上述规则，产生新的∏ 循环2，直到∏中的每个状态集合都不可以再划分 得到最终的∏，包含s0的状态集合为新的初始状态，包含F的状态集合构成新的终态集，然后对于其中的每个状态集合，用状态集合中的某一个元素代替该集合，并继承所有对该集合的状态转移函数 删除死状态和不可达状态 例： 初始划分∏&#x3D;{ABCD,E} ∏[2]不可再划分，所以只遍历ABCD，ABCD接受a都到达B，B属于∏[1]，ABC接受b分别到达CDC，CDC都属于∏[1]所以ABC不可区分，划分为同一组，而D接受b到达E，E属于∏[2]，所以D划分为另一组，于是∏更新为{ABC,D,E} 同理对ABC遍历，∏更新为{AC,B,D,E} 对AC遍历，AC不可再划分，此时所有组都已经不可被划分，所以最终∏&#x3D;{AC,B,D,E} 选代表，用A代替组AC，更新状态转移表，删除死状态和不可达状态（此例没有）得到DFA如图 5. 构造词法分析器（基于DFA）5.1 表驱动型词法分析器使用时，驱动器调用DFA查表 5.2 直接编码型词法分析器将驱动器和DFA操作合并，直接模拟DFA输入 5.3 对比 表驱动 直接编码 分析器速度 慢 快 程序与模式关系 无关 有关 适合的编写方式 工具生成 手工编程 分析器的规模 较大 较小 三. 语法分析词法分析：字母是元素，组成字符串，记号的集合，线性结构语法分析：记号是元素，组成句子，句子的集合，树结构语法的含义： 语法规则：上下文无关法 语法分析：下推自动机，自上而下和自下而上分析 1. 基本概念语法分析器作用： 根据词法分析器提供的记号流，构造语法树 检查输入中的语法（可能包括词法）错误，并调用出错处理器进行处理。 源程序中出现的错误： 词法错误：如非法字符、拼写错误（20id，intege） 语法错误：语法结构出错，如缺少分号、begin&#x2F;end不匹配 静态语义错误：如类型不一致、参数不匹配 动态语义错误（逻辑错误）：如死循环、除数为0 错误的恢复策略 紧急方式恢复：抛弃若干输入，直到接受合法输入 短语级恢复：采用串替换方式（抛弃+插入）方式对剩余输入局部纠正 出错产生式：用出错产生式捕捉错误，用预制的短语级恢复 全局纠正：寻找相近输入序列 2. 上下文无关法（CFG）2.1 定义CFG是一个四元组：G&#x3D;(N,T,P,S)其中： N是非终结符的有限集合 T是终结符的有限集合，且N∩T&#x3D;ф P是产生式的有限集合（产生式A-&gt;a，其中A∈N（左部），a∈(N∪T)*（右部），若a&#x3D;ε，则称A-&gt;ε为空产生式，也记为A-&gt;） S是非终结符，称为文法的开始符号 2.2 表示方法由产生式集表示CFG约定： 第一个产生式左部是文法开始符号S 大写英文字母表示非终结符，小写英文字母表示终结符分析树 当若干个产生式左部相同时，可以将它们合并为一个产生式，所有右部用或运算连接 例：简单的算术表达式可以表示为N&#x3D;{E} T&#x3D;{+,*,(,),-,id} S&#x3D;Ep:E-&gt;E + EE-&gt;E * EE-&gt;(E)E-&gt;-EE-&gt;id或者表示为E-&gt;E + E|E * E|(E)|-E|id 2.3 上下文无关语言（由CFG定义的语言）推导推导是产生语言的方法 直接推导：对于产生式A-&gt;$\\gamma$，令$\\alpha A\\beta$替换为$\\alpha\\gamma\\beta$的过程叫做直接推导，记作$\\alpha A\\beta\\Rightarrow\\alpha\\gamma\\beta$ 零步或多步推导：$\\alpha1\\Rightarrow\\alpha2\\Rightarrow…\\Rightarrow\\alpha n$，记作$\\alpha1\\Rightarrow^*\\alpha n$，其中$\\alpha1&#x3D;\\alpha2$的情况为零步推导 至少一步推导：对于零步或多步推导，若$\\alpha1\\not&#x3D;\\alpha n$则为至少一步推导，记作$\\alpha1\\Rightarrow^+\\alpha n$ 若每次推导均替换句型中最左边非终结符，则称为最左推导，由最左推导产生的句型为左句型，另外最右推导也被称为规范推导 语言由上可知：由CFG G产生的语言L(G)被定义为：L(G)&#x3D;{$\\omega$|$S\\Rightarrow^+\\omega$ and $\\omega\\in T^*$ }L(G)称为上下文无关语言，$\\omega$称为句子（句型：若 $S\\Rightarrow^\\alpha,\\alpha\\in(N\\cap T)^$，则$\\alpha$为G的一个句型） 例：N&#x3D;{E} T&#x3D;{+,*,(,),-,id} S&#x3D;E可有以下推导：$E\\Rightarrow-E\\Rightarrow-(E)\\Rightarrow-(E+E)\\Rightarrow-(id+E)\\Rightarrow-(id+id)$ （了解什么是二义性，和消除二义性的方法，不要求具体实现）二义性：若文法 G 对 同 一句子产生不止一棵分析树，则称G是二义的造成文法二义性的原因：文法对文法符号优先级缺少规定消除二义性：4. 改写二义文法为非二义文法5. 规定二义文法中符号的优先级和结合性（3. 修改语言的语法） 上下文有关语言如变量引用与声明必须一致过程调用时实参与形参的个数、类型必须一致等 3. 自上而下语法分析对于任意一个输入序列（记号流），从S开始进行最左推导，直到得到一个合法的句子或发现一个非法结构 结语：&emsp;&emsp;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"编译原理","slug":"笔记/编译原理","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"目标检测算法Yolo(二)—YoloV1V2原理及源码使用","slug":"目标检测算法Yolo-二-—YoloV1V2原理及源码使用","date":"2023-10-30T03:46:34.000Z","updated":"2023-11-28T09:06:00.461Z","comments":true,"path":"2023/10/30/目标检测算法Yolo-二-—YoloV1V2原理及源码使用/","link":"","permalink":"http://example.com/2023/10/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95Yolo-%E4%BA%8C-%E2%80%94YoloV1V2%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介：&emsp;&emsp;本类博客用于记录目标检测方法yolo的学习，本篇博客介绍了yolov1，yolov2的原理，和yolo源码的下载和使用 参考资料： 【百万播放】零基础、快速学YOLO目标检测算法！完整学习路线一条龙，无脑通关！【YOLOv5|YOLO算法|目标检测算法】_哔哩哔哩_bilibili &emsp;&emsp;Yolo属于one-stage的目标检测，优点是速度快，实时检测，缺点是牺牲效果 一、Yolo原理1.评估指标1.1 MAP&emsp;&emsp;查准率：预测对的正样本占所有预测为正样本的比值&emsp;&emsp;召回率：预测对的正样本占所有正样本的比值&emsp;&emsp;AP：将该类别预测样本按置信度排序，分别计算查准率和召回率，绘制查准率关于召回率的图像，计算面积&emsp;&emsp;MAP：将每个类的AP平均&emsp;&emsp;&#x4d;&#x41;&#80;&#x40;&#x30;&#46;&#53;:9.5：使用不同的IOU并平均 1.2 IOU&emsp;&emsp;真实值和预测值并集比上交集 ，越接近1效果越好 1.3 前传耗时&emsp;&emsp;从输入一张图像到输出结果所耗时间 1.4 FPS&emsp;&emsp;每秒能处理的图像数量 2. YoloV1 填充图片并缩放至448*448 获取每张图片的labels（包括每个目标的x,y,w,h,p） 设置网络结构 其中最后的输出结果为7 * 7 * 30的向量，其含义为将网络分成7*7个格子，每个格子包含两个候选框的信息（x,y,w,h,p)和20个类别的预测概率，共计30个元素 计算损失函数 3. YoloV2改进 增加了448*448的图片的训练 删除了全连接层 根据聚类选择先验框 x,y,w,h改为相对于先验框的偏移量 特征融合，利于检测小目标 二. Yolo源码1.源码下载和配置环境&emsp;&emsp;进入ultralytics&#x2F;yolov5 at v5.0 (github.com)下载源码，然后使用pip install -r yourpath/requirements.txt下载所需库（可以把requirements中关于toch，tochvision的部分删了自己下载，按照requirements中安装的torch是cpu版本的） 2.源码使用&emsp;&emsp;更改参数为你对应的 2.1 detect.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def parse_opt(): parser = argparse.ArgumentParser() #指定训练模型 defult选择训练模型 parser.add_argument(&#x27;--weights&#x27;, nargs=&#x27;+&#x27;, type=str, default=ROOT / &#x27;yolov5s.pt&#x27;, help=&#x27;model path(s)&#x27;) #指定预测对象来源 default可选为： #file.jpg #file.mp4 #path/ #path/*/jpg #检测所有jpg文件 #YouTube video地址 parser.add_argument(&#x27;--source&#x27;, type=str, default=ROOT / &#x27;data/images&#x27;, help=&#x27;file/dir/URL/glob, 0 for webcam&#x27;) parser.add_argument(&#x27;--data&#x27;, type=str, default=ROOT / &#x27;data/coco128.yaml&#x27;, help=&#x27;(optional) dataset.yaml path&#x27;) #图片尺寸 parser.add_argument(&#x27;--imgsz&#x27;, &#x27;--img&#x27;, &#x27;--img-size&#x27;, nargs=&#x27;+&#x27;, type=int, default=[640], help=&#x27;inference size h,w&#x27;) #置信度阈值 parser.add_argument(&#x27;--conf-thres&#x27;, type=float, default=0.25, help=&#x27;confidence threshold&#x27;) #交集阈值，大于该值就判定为同一目标，合并框 parser.add_argument(&#x27;--iou-thres&#x27;, type=float, default=0.45, help=&#x27;NMS IoU threshold&#x27;) parser.add_argument(&#x27;--max-det&#x27;, type=int, default=1000, help=&#x27;maximum detections per image&#x27;) #设备 parser.add_argument(&#x27;--device&#x27;, default=&#x27;&#x27;, help=&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;) #是否展示结果 parser.add_argument(&#x27;--view-img&#x27;, action=&#x27;store_true&#x27;, help=&#x27;show results&#x27;) #保存一些结果 parser.add_argument(&#x27;--save-txt&#x27;, action=&#x27;store_true&#x27;, help=&#x27;save results to *.txt&#x27;) parser.add_argument(&#x27;--save-conf&#x27;, action=&#x27;store_true&#x27;, help=&#x27;save confidences in --save-txt labels&#x27;) parser.add_argument(&#x27;--save-crop&#x27;, action=&#x27;store_true&#x27;, help=&#x27;save cropped prediction boxes&#x27;) parser.add_argument(&#x27;--nosave&#x27;, action=&#x27;store_true&#x27;, help=&#x27;do not save images/videos&#x27;) #指定检测某些类别 parser.add_argument(&#x27;--classes&#x27;, nargs=&#x27;+&#x27;, type=int, help=&#x27;filter by class: --classes 0, or --classes 0 2 3&#x27;) #增强 parser.add_argument(&#x27;--agnostic-nms&#x27;, action=&#x27;store_true&#x27;, help=&#x27;class-agnostic NMS&#x27;) parser.add_argument(&#x27;--augment&#x27;, action=&#x27;store_true&#x27;, help=&#x27;augmented inference&#x27;) parser.add_argument(&#x27;--visualize&#x27;, action=&#x27;store_true&#x27;, help=&#x27;visualize features&#x27;) #屏蔽不需要的优化器 parser.add_argument(&#x27;--update&#x27;, action=&#x27;store_true&#x27;, help=&#x27;update all models&#x27;) #保存地址 parser.add_argument(&#x27;--project&#x27;, default=ROOT / &#x27;runs/detect&#x27;, help=&#x27;save results to project/name&#x27;) parser.add_argument(&#x27;--name&#x27;, default=&#x27;exp&#x27;, help=&#x27;save results to project/name&#x27;) #是否创建新文件夹保存结果 parser.add_argument(&#x27;--exist-ok&#x27;, action=&#x27;store_true&#x27;, help=&#x27;existing project/name ok, do not increment&#x27;) parser.add_argument(&#x27;--line-thickness&#x27;, default=3, type=int, help=&#x27;bounding box thickness (pixels)&#x27;) parser.add_argument(&#x27;--hide-labels&#x27;, default=False, action=&#x27;store_true&#x27;, help=&#x27;hide labels&#x27;) parser.add_argument(&#x27;--hide-conf&#x27;, default=False, action=&#x27;store_true&#x27;, help=&#x27;hide confidences&#x27;) parser.add_argument(&#x27;--half&#x27;, action=&#x27;store_true&#x27;, help=&#x27;use FP16 half-precision inference&#x27;) parser.add_argument(&#x27;--dnn&#x27;, action=&#x27;store_true&#x27;, help=&#x27;use OpenCV DNN for ONNX inference&#x27;) opt = parser.parse_args() opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1 # expand print_args(vars(opt)) return opt 2.2 train.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def parse_opt(known=False): parser = argparse.ArgumentParser() #指定初始化参数，可不填 parser.add_argument(&#x27;--weights&#x27;, type=str, default=ROOT / &#x27;yolov5s.pt&#x27;, help=&#x27;initial weights path&#x27;) #指定网络的结构 parser.add_argument(&#x27;--cfg&#x27;, type=str, default=&#x27;&#x27;, help=&#x27;model.yaml path&#x27;) #指定数据集 parser.add_argument(&#x27;--data&#x27;, type=str, default=ROOT / &#x27;data/coco128.yaml&#x27;, help=&#x27;dataset.yaml path&#x27;) #超参数 parser.add_argument(&#x27;--hyp&#x27;, type=str, default=ROOT / &#x27;data/hyps/hyp.scratch-low.yaml&#x27;, help=&#x27;hyperparameters path&#x27;) #训练轮数 parser.add_argument(&#x27;--epochs&#x27;, type=int, default=300) #打包数据集的大小 parser.add_argument(&#x27;--batch-size&#x27;, type=int, default=16, help=&#x27;total batch size for all GPUs, -1 for autobatch&#x27;) #图片大小 parser.add_argument(&#x27;--imgsz&#x27;, &#x27;--img&#x27;, &#x27;--img-size&#x27;, type=int, default=640, help=&#x27;train, val image size (pixels)&#x27;) #矩阵填充 parser.add_argument(&#x27;--rect&#x27;, action=&#x27;store_true&#x27;, help=&#x27;rectangular training&#x27;) #是否在已训练的模型上继续训练 parser.add_argument(&#x27;--resume&#x27;, nargs=&#x27;?&#x27;, const=True, default=False, help=&#x27;resume most recent training&#x27;) #是否只保存最后的模型 parser.add_argument(&#x27;--nosave&#x27;, action=&#x27;store_true&#x27;, help=&#x27;only save final checkpoint&#x27;) parser.add_argument(&#x27;--noval&#x27;, action=&#x27;store_true&#x27;, help=&#x27;only validate final epoch&#x27;) #锚点 锚框 parser.add_argument(&#x27;--noautoanchor&#x27;, action=&#x27;store_true&#x27;, help=&#x27;disable AutoAnchor&#x27;) parser.add_argument(&#x27;--noplots&#x27;, action=&#x27;store_true&#x27;, help=&#x27;save no plot files&#x27;) parser.add_argument(&#x27;--evolve&#x27;, type=int, nargs=&#x27;?&#x27;, const=300, help=&#x27;evolve hyperparameters for x generations&#x27;) parser.add_argument(&#x27;--bucket&#x27;, type=str, default=&#x27;&#x27;, help=&#x27;gsutil bucket&#x27;) parser.add_argument(&#x27;--cache&#x27;, type=str, nargs=&#x27;?&#x27;, const=&#x27;ram&#x27;, help=&#x27;--cache images in &quot;ram&quot; (default) or &quot;disk&quot;&#x27;) parser.add_argument(&#x27;--image-weights&#x27;, action=&#x27;store_true&#x27;, help=&#x27;use weighted image selection for training&#x27;) parser.add_argument(&#x27;--device&#x27;, default=&#x27;&#x27;, help=&#x27;cuda device, i.e. 0 or 0,1,2,3 or cpu&#x27;) #图片尺寸变换 parser.add_argument(&#x27;--multi-scale&#x27;, action=&#x27;store_true&#x27;, help=&#x27;vary img-size +/- 50%%&#x27;) parser.add_argument(&#x27;--single-cls&#x27;, action=&#x27;store_true&#x27;, help=&#x27;train multi-class data as single-class&#x27;) parser.add_argument(&#x27;--optimizer&#x27;, type=str, choices=[&#x27;SGD&#x27;, &#x27;Adam&#x27;, &#x27;AdamW&#x27;], default=&#x27;SGD&#x27;, help=&#x27;optimizer&#x27;) parser.add_argument(&#x27;--sync-bn&#x27;, action=&#x27;store_true&#x27;, help=&#x27;use SyncBatchNorm, only available in DDP mode&#x27;) #线程数 parser.add_argument(&#x27;--workers&#x27;, type=int, default=8, help=&#x27;max dataloader workers (per RANK in DDP mode)&#x27;) parser.add_argument(&#x27;--project&#x27;, default=ROOT / &#x27;runs/train&#x27;, help=&#x27;save to project/name&#x27;) parser.add_argument(&#x27;--name&#x27;, default=&#x27;exp&#x27;, help=&#x27;save to project/name&#x27;) parser.add_argument(&#x27;--exist-ok&#x27;, action=&#x27;store_true&#x27;, help=&#x27;existing project/name ok, do not increment&#x27;) parser.add_argument(&#x27;--quad&#x27;, action=&#x27;store_true&#x27;, help=&#x27;quad dataloader&#x27;) parser.add_argument(&#x27;--cos-lr&#x27;, action=&#x27;store_true&#x27;, help=&#x27;cosine LR scheduler&#x27;) parser.add_argument(&#x27;--label-smoothing&#x27;, type=float, default=0.0, help=&#x27;Label smoothing epsilon&#x27;) parser.add_argument(&#x27;--patience&#x27;, type=int, default=100, help=&#x27;EarlyStopping patience (epochs without improvement)&#x27;) parser.add_argument(&#x27;--freeze&#x27;, nargs=&#x27;+&#x27;, type=int, default=[0], help=&#x27;Freeze layers: backbone=10, first3=0 1 2&#x27;) parser.add_argument(&#x27;--save-period&#x27;, type=int, default=-1, help=&#x27;Save checkpoint every x epochs (disabled if &lt; 1)&#x27;) parser.add_argument(&#x27;--seed&#x27;, type=int, default=0, help=&#x27;Global training seed&#x27;) parser.add_argument(&#x27;--local_rank&#x27;, type=int, default=-1, help=&#x27;Automatic DDP Multi-GPU argument, do not modify&#x27;) # Weights &amp; Biases arguments parser.add_argument(&#x27;--entity&#x27;, default=None, help=&#x27;W&amp;B: Entity&#x27;) parser.add_argument(&#x27;--upload_dataset&#x27;, nargs=&#x27;?&#x27;, const=True, default=False, help=&#x27;W&amp;B: Upload data, &quot;val&quot; option&#x27;) parser.add_argument(&#x27;--bbox_interval&#x27;, type=int, default=-1, help=&#x27;W&amp;B: Set bounding-box image logging interval&#x27;) parser.add_argument(&#x27;--artifact_alias&#x27;, type=str, default=&#x27;latest&#x27;, help=&#x27;W&amp;B: Version of dataset artifact to use&#x27;) return parser.parse_known_args()[0] if known else parser.parse_args() 结语：无&emsp;&emsp;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"人工智能","slug":"笔记/人工智能","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"yolo","slug":"笔记/人工智能/yolo","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/yolo/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"目标检测算法Yolo(一)—环境配置Pytorch","slug":"目标检测算法Yolo-一-—环境配置Pytorch","date":"2023-10-30T03:25:33.000Z","updated":"2023-11-28T09:06:00.461Z","comments":true,"path":"2023/10/30/目标检测算法Yolo-一-—环境配置Pytorch/","link":"","permalink":"http://example.com/2023/10/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95Yolo-%E4%B8%80-%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEPytorch/","excerpt":"","text":"简介：&emsp;&emsp;本类博客用于记录目标检测方法yolo的学习，本篇博客介绍了yolo的环境配置—pytorch 参考资料： PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】_哔哩哔哩_bilibili &emsp;&emsp;Pytorch是torch的python版本，是由Facebook开源的神经网络框架，专门针对 GPU 加速的深度神经网络（DNN）编程。Torch 是一个经典的对多维矩阵数据进行操作的张量（tensor ）库，在机器学习和其他数学密集型应用有广泛应用。与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。但由于Torch语言采用 Lua，导致在国内一直很小众，并逐渐被支持 Python 的 Tensorflow 抢走用户。作为经典机器学习库 Torch 的端口，PyTorch 为 Python 语言使用者提供了舒适的写代码选择。 一.Pytorch安装及环境配置1. Pytorch的安装1.1 Anaconda安装&emsp;&emsp;此处我选用的是Anaconda3-5.2.0-Windows-x86_64.exe版本&emsp;&emsp;Ananconda作用是为pytorch提供一个独立的虚拟环境，里面可以独立地配置环境，避免和系统环境等冲突，便于管理环境，同时配置过程中有没法解决的问题都可以删除虚拟环境重来 超详细Anaconda安装教程_极小白的博客-CSDN博客 1.2 pytorch的环境配置及安装&emsp;&emsp;打开Anaconda Prompt 输入&emsp;&emsp;conda create -n pytorch python=3.6&emsp;&emsp;创建了一个新环境，然后使用如下命令进入环境&emsp;&emsp;conda activate pytorch&emsp;&emsp;之后需要安装gpu版本的pytorch，按照视频教程去pytorch.org使用官方命令安装pytorch怎么样安装的都是cpu版本，找了很多教程，都没有用，最直接的解决方案是自己下载离线文件，此处按照下面这个教程安装 pytorch gpu版安装（普适稳妥，亲测有效） - 知乎 (zhihu.com) &emsp;&emsp;在环境里安装torchvision时报错ReadTimeout，可能是安装依赖的问题，解决方法：设置pip全局设置镜像源 12pip3 config --global set global.index-url https://mirrors.aliyun.com/pypi/simple/pip3 config --global set install.trusted-host &emsp;&emsp;检验是否安装成功，依次输入 123pythonimport torchtorch.cuda.is_available() &emsp;&emsp;返回True代表成功&emsp;&emsp;配置和安装pytorch遇到了很多报错，终于是成功了，如果觉得有问题，可以把环境文件夹删了重来一遍（我的文件夹路径为C:\\Users\\Frelar\\Anaconda3\\envs\\） 2. python的编辑器及配置2.1 PyCharm&emsp;&emsp;此处建议下载新版本&emsp;&emsp;编译器选择你对应虚拟环境即可 2.2 Jupyter Notebook（可选）&emsp;&emsp;按照教程下载报错，改为在Anaconda Promot（pytorch环境）里输入conda install jupyter notebook，下载后new选项里没有当前环境，依次输入 12conda install ipykernelpython -m ipykernel install --user --name pytorch --display-name &quot;Python (pytorch)&quot; 成功解决 3. 其它相关库3.1 opencv&emsp;&emsp;这里使用pip install opencv-python安装报错Failed building wheel for opencv-python，然后尝试用conda安装，报错找不到库，所以还是采用离线下载方式，进入网址Archived: Python Extension Packages for Windows - Christoph Gohlke (uci.edu)找到你对应的python版本（cp36代表python3.6），使用迅雷下载会快很多，然后在环境下使用pip install your_path\\opencv_python-4.4.0-cp36-cp36m-win_amd64.whl安装成功 &emsp;&emsp;import cv2 1cv2.imread() #读取图片，返回ndarray类型图片及信息 3.2 os&emsp;&emsp;import os 12os.listdir(dir_path) #读取获取目录下所有文件名称os.path.join(path1,path2) #拼接路径 二.Pytorch使用1.torch1.1 torch.utils.data.Dataset&emsp;&emsp;from torch.utils.data import Dataset&emsp;&emsp;包含自定义数据集方法的类，用户可以通过继承该类来自定义自己的数据集类，在继承时要求用户重载__len__()和__getitem__()这两个魔法方法 1234567891011121314151617181920212223242526from torch.utils.data import Dataset from PIL import Image import os class MyData(Dataset): def __init__(self,root_dir,label_dir): self.root_dir=root_dir #根目录 self.label_dir=label_dir #标签 self.path=os.path.join(root_dir,label_dir) #图片目录 self.image_path=os.listdir(self.path) #所有图片名称 def __getitem__(self, idx): img_name=self.image_path[idx] img_idx_path=os.path.join(self.path,img_name) img=Image.open(img_idx_path) label=self.label_dir return img,label #图片信息，标签 def __len__(self): return len(self.image_path) #图片个数 root_dir=&quot;dataSet/train&quot; cat_label_dir=&quot;cat&quot; cat_dataSet=MyData(root_dir,cat_label_dir) #实例 1.2 torch.utils.data. DataLoader&emsp;&emsp;from torch.utils.data import DataLoader 1234train_loader=DataLoader(dataset=train_data,batch_size=64,shuffle=True,num_workers=0,drop_last=True)#数据集，每次打包的图片数，是否打乱，线程数，是否丢弃不够一组打包的图片#for data in train_loader# imgs,target=data #读取图片信息 1.3 torch.nn&emsp;&emsp;from torch import nn&emsp;&emsp;一个用于创建神经网络模型的类,可以作为参数、容器、子模块和函数 123456789101112131415161718192021222324252627#神经网络骨架class Name(nn.moudle): def __init__(self): super(Name,self).__init__() self.layer=layerFunc() #激活层 def forward(self,input) #前向传播 output=self.layer(input) return outputname=Name()output=name(input)name.train() #训练模式name.eval() #验证模式#卷积nn.Conv2d(in_channels=3,out_channels=6,kernel_size=3,stride=1,padding=0) #二维卷积（输入通道数，输出通道数，卷积核层数...）#池化nn.MaxPool2d(kernel_size=3,ceil_mode=True) #最大池化（核大小，步长（默认为核大小），是否填充是否舍弃不足核大小的图片部分）#非线性激活nn.sigmoid(inplace=False) #sigmoid激活（是否原地操作）#线性激活nn.Liner(input_features,output_features,bias=False) #线性激活（输入特征数，输出特征数，偏置）#序列nn.Sequential(fun1,fun2...,funN) #包装操作为序列，可读性更强#损失函数、反向传播loss=nn.CrossEntropyLoss()result_loss=loss(outputs,targets)result_loss.backword() #反向传播 将梯度记录在每层信息的weight里 1.4 torch.optim&emsp;&emsp;import torch&emsp;&emsp;用于参数优化的库（可以说是花式梯度下降） 12345optim=torch.optim.SGD(yourClass.parameters(),lr=0.01) #优化器（参数集，学习速率）#result.loss=loss(outputs,targets)#optim.zero_grad() #初始化梯度#result_loss.backword()#optim.step() 2.torchvision&emsp;&emsp;import torchvision&emsp;&emsp;处理图像的工具集 1234#获取数据集train_set=torchvision.datasets.dataname(root=&quot;./dataset&quot;,train=True,transforms=mytransform,download=True)#train_set.classes 数据集的各种类名（猫、狗...）#img,target=train_set[0] 图片信息，图片类名编号 2.1 torchvision.transforms&emsp;&emsp;from torchvision import transforms&emsp;&emsp;对图片进行操作&emsp;&emsp;使用方法： 12mytool=transforms.tool(arguments1) #实例化mytool(arguments2) #使用 &emsp;&emsp;tool: 123456789101112myToTensor=transforms.ToTensor()myImg=myToTensor(img) #将PIL或numpy.ndarry类型图片转为tensor类型并返回#tensor类型：包装了神经网络的一些参数myCompose=transforms.Compose(n)myImg=myCompose(img) #中心裁剪myNorm=transforms.Normalize([mean1...meanN],[std1...stdN]) #每个通道的均值和方差myImg=myNorm(img) #归一化myResize=transforms.Resize((h,w))myImg=myResize(img) #缩放 3.利用GPU加速123456#方法一if torch.cuda.is_available(): #判断GPU加速是否可用 item=item.cuda() #目标加速（可用于：imgs/targets/yourMoudle/loss）#方法二device=torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) item=item.to(device) 遇到问题：1.pip insall或者conda install很多报错，如找不到库，超时等2. 安装cuda版本的pytorch总是安装成cpu（大坑）解决方案：1.采用离线下载方式，手动下载.whl文件 然后pip install yourPath.whl2.采用离线下载是唯一解决方法 结语：无&emsp;&emsp;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"人工智能","slug":"笔记/人工智能","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"yolo","slug":"笔记/人工智能/yolo","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/yolo/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"会议室预约系统(一)—QT开发数据库学习","slug":"会议室预约系统-一-—QT开发数据库学习","date":"2023-10-29T15:16:04.000Z","updated":"2023-11-28T09:06:00.462Z","comments":true,"path":"2023/10/29/会议室预约系统-一-—QT开发数据库学习/","link":"","permalink":"http://example.com/2023/10/29/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F-%E4%B8%80-%E2%80%94QT%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录QT软件结合数据库开发的学习过程 参考资料： 最新QT从入门到实战完整版|传智教育_哔哩哔哩_bilibili Qt零基础系列10：使用Qt如何操作数据库 - 知乎 (zhihu.com) 一.QT1.控件1.1 窗体12345678910myWidget w; //创建窗体//set类setWindowTitle(&quot;窗口名称&quot;) //设置窗口名称resize(w,h) //重置窗口大小setFixedSize(w.h) //设置固定窗口大小//print类show() //显示窗口 1.2 按钮1234567891011#include &lt;QPushButton&gt;QPushButton* btn=new QPushButton(&quot;按钮名称&quot;,父窗口); //创建按钮在父窗口内（不填默认新开窗口创建）setText();setParent();move(x,y); //移动按钮resize(w,h);//信号clicked(); 1.3 对话框12345#include &lt;QDialog&gt;exec() //阻塞其他操作（模态）//消息对话框QMessageBox::critical(父类,标题,信息) //错误对话框QMessageBox::information(父类,标题,信息) //信息提示对话框 1.4 编辑框1234#include &lt;QLineEdit&gt;text();setText();setReadOnly(true); 1.5 文本编辑框12#include &lt;QtextEdit&gt;toPlainText(); //获取文本内容 1.6 下拉式选项框12345#include &lt;QComboBox&gt;currentIndex(); //当前选项编号//信号currentIndexChanged(); 2.信号和槽信号和槽是指，当某一控件被操作时，发出信号，然后由信号接收者接收信号，并通过槽函数处理信号 1connect(信号发送者,信号(函数地址),信号接收者,处理信号函数(槽函数地址); 自定义信号：无返回值写在signal下需要声明不需要实现可以带参数，可以重载（参数要多于槽函数参数） 自定义槽：无返回值一般的声明在public slots下需要实现可以带参数，可以重载 重载后 connect需要如下实现： 12void(ClassName:: *p)(参数)=&amp;ClassName::函数名;connect(class,p,...) 触发信号 1emit 函数名; 断开信号 1discount(); 3.QT设计联合代码开发点击界面文件中的mainwindow.ui，然后进行界面设计，完成后打开Qt 6.4.3(MinGW 11.2.0 64-bit) （打开你对应版本即可），cd 到你界面文件所在的文件夹，输入：uic -o ui.h mainwindow.ui即可在该文件夹生成ui.h头文件 使用时先实例化ui.h类：Ui_mainWindow ui=Ui_mainWindow();然后调用setupUi()方法：ui.setupUi(yourWindow_address);这时你的界面就和你设计的界面一样了 获取你的界面的控件的方法：QType* a= yourWindow-&gt;findChild&lt;QType*&gt;(&quot;itemName&quot;); 二.数据库qt使用数据库步骤： 下载Mysql（网上很多教程） 本地&#x2F;服务器创建数据库 建立数据库链接（和你创建的数据库一致）（详细代码见参考资料） 本地&#x2F;服务器创建表 qt中执行sql语句对数据库增删查改 qt执行sql语句步骤： 1234567891011121314151617//1.在建立好数据库链接后获取数据库链接QSqlDatabase db=QSqlDatabase::database(connectionName);//2.传入数据库链接QSqlQuery query(db);//3.设计sql语句query.prepare(&quot;SELECT * FROM conference_users WHERE users_name=:users_name&quot;);query.bindValue(&quot;:users_name&quot;,name);//或者QString sql = &quot;SELECT * FROM conference_users WHERE users_name=&#x27;&quot; + name + &quot;&#x27;&quot;;//4.执行sql语句if(!query.exec(sql)) qDebug()&lt;&lt;&quot;查找失败&quot;;//5.获取结果if(query.size()==0) return NULL;while (query.next())&#123; QString str=query.value(1).toString(); //...&#125; 结语：熟练使用QT设计和代码联合开发很重要&emsp;&emsp;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"程序设计","slug":"项目/程序设计","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"会议室系统","slug":"项目/程序设计/会议室系统","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"qt","slug":"qt","permalink":"http://example.com/tags/qt/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]},{"title":"会议室预约系统(二)—代码实现","slug":"会议室预约系统-二-—代码实现","date":"2023-10-29T14:53:54.000Z","updated":"2023-11-28T09:06:00.463Z","comments":true,"path":"2023/10/29/会议室预约系统-二-—代码实现/","link":"","permalink":"http://example.com/2023/10/29/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F-%E4%BA%8C-%E2%80%94%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于介绍使用QT软件、Mysql开发会议室预约系统的代码，代码已经发布到https://github.com/arrowonstr/conferenceRoomReservationSystem 一.环境该系统使用C++ QT开发，使用方法： 下载代码 将所有head、source中文件取出和其他文件放在同一目录下 使用QT软件打开项目打开.pro文件 配置对应数据库，具体数据库内容见本文 二. ，或修改代码符合自己的数据库 运行 二.系统流程图其中： 大矩形框代表界面 正方形框代表按钮 小矩形框代表下拉式选项 实线箭头代表按钮按下后打开&#x2F;更新某一界面 虚线箭头代表按钮按下后向调用数据库 流程图仅表示大致流程，许多细节是被隐藏的，具体可以看代码 三.数据库配置数据库需要配置为下面对应配置，或者修改mycfsql.cpp文件中的createConnectionByName函数，以及signwindow.cpp构造函数中cf.createConnectionByName(&quot;conference&quot;)数据库名表需要完全相同配置 1.数据库服务器：本地数据库名：conference用户名：root密码：1234端口号：3306 2.表2.1 conference_users 字段名称 数据类型 是否为可空 默认值 含义 users_id int NO NULL id users_name varchar(20) NO NULL 用户名 users_password varchar(20) NO NULL 密码 users_author int NO NULL 权限 其中： users_id为主键 权限 0为用户 1为管理员 2.2 conference_rooms 字段名称 数据类型 是否为可空 默认值 含义 rooms_id int NO NULL id rooms_name varchar(20) NO NULL 名称 rooms_number int NO NULL 房号 rooms_capacity int NO NULL 最大人数 rooms_square int NO NULL 面积 rooms_describe varchar(50) NO NULL 描述 rooms_reserve varchar(12) NO NULL 无 其中： rooms_id为主键 rooms_reserve为废弃的字段 但是不想改代码了 所以保留在这里 其没有含义和作用 2.3 conference_reserves 字段名称 数据类型 是否为可空 默认值 含义 reserves_id int NO NULL id reserves_user varchar(20) NO NULL 预约用户 reserves_number int NO NULL 预约房号 reserves_stime datetime NO NULL 开始时间 reserves_etime datetime NO NULL 结束时间 reserves_subject varchar(20) NO NULL 主题 reserves_capacity int NO NULL 人数 reserves_state int NO NULL 状态 reserves_describe varchar(50) NO NULL 描述 其中：reserves_id为主键状态 0未审批 1未审批 2为驳回 3为取消 结语：无&emsp;&emsp;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"程序设计","slug":"项目/程序设计","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"会议室系统","slug":"项目/程序设计/会议室系统","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"qt","slug":"qt","permalink":"http://example.com/tags/qt/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]},{"title":"K210开发板(六)-yolo目标检测","slug":"K210开发板-六-yolo目标检测","date":"2023-09-23T08:28:11.000Z","updated":"2023-11-28T09:06:00.483Z","comments":true,"path":"2023/09/23/K210开发板-六-yolo目标检测/","link":"","permalink":"http://example.com/2023/09/23/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E5%85%AD-yolo%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"","text":"简介：&emsp;&emsp; 一、实验准备1.Pytorch&emsp;&emsp;Pytorch是torch的python版本，是由Facebook开源的神经网络框架，专门针对 GPU 加速的深度神经网络（DNN）编程。Torch 是一个经典的对多维矩阵数据进行操作的张量（tensor ）库，在机器学习和其他数学密集型应用有广泛应用。与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。但由于Torch语言采用 Lua，导致在国内一直很小众，并逐渐被支持 Python 的 Tensorflow 抢走用户。作为经典机器学习库 Torch 的端口，PyTorch 为 Python 语言使用者提供了舒适的写代码选择。 1.1 Pytorch的安装1.1.1 Anaconda安装&emsp;&emsp;此处我选用的是Anaconda3-5.2.0-Windows-x86_64.exe版本 超详细Anaconda安装教程_极小白的博客-CSDN博客 1.1.2 pytorch的环境配置及安装&emsp;&emsp;打开Anaconda Prompt 输入&emsp;&emsp;conda create -n pytorch python=3.6&emsp;&emsp;创建了一个新环境，然后使用如下命令进入环境&emsp;&emsp;conda activate pytorch&emsp;&emsp;之后需要安装gpu版本的pytorch，按照视频教程去pytorch.org使用官方命令安装pytorch怎么样安装的都是cpu版本，找了很多教程，都没有用，最直接的解决方案是自己下载离线文件，此处按照下面这个教程安装 pytorch gpu版安装（普适稳妥，亲测有效） - 知乎 (zhihu.com) &emsp;&emsp;在环境里安装torchvision时报错ReadTimeout，可能是安装依赖的问题，解决方法：设置pip全局设置镜像源 12pip3 config --global set global.index-url https://mirrors.aliyun.com/pypi/simple/pip3 config --global set install.trusted-host &emsp;&emsp;检验是否安装成功，依次输入 123pythonimport torchtorch.cuda.is_available() &emsp;&emsp;返回True代表成功&emsp;&emsp;配置和安装pytorch遇到了很多报错，终于是成功了，如果觉得有问题，可以把环境文件夹删了重来一遍（我的文件夹路径为C:\\Users\\Frelar\\Anaconda3\\envs\\） 1.2 python的编辑器及配置1.2.1 PyCharm&emsp;&emsp;下载2023版使用import torch报错了 下回2019版成功 1.2.2 Jupyter Notebook&emsp;&emsp;按照教程下载报错，改为在Anaconda Promot（pytorch环境）里输入conda install jupyter notebook，下载后new选项里没有当前环境，依次输入 12conda install ipykernelpython -m ipykernel install --user --name pytorch --display-name &quot;Python (pytorch)&quot; 成功解决 1.3 一些库1.3.1 opencv&emsp;&emsp;这里使用pip install opencv-python安装报错Failed building wheel for opencv-python，然后尝试用conda安装，报错找不到库，所以还是采用离线下载方式，进入网址Archived: Python Extension Packages for Windows - Christoph Gohlke (uci.edu)找到你对应的python版本（cp36代表python3.6），使用迅雷下载会快很多，然后在环境下使用pip install your_path\\opencv_python-4.4.0-cp36-cp36m-win_amd64.whl安装成功 &emsp;&emsp;import cv2 1cv2.imread() #读取图片，返回ndarray类型图片及信息 1.3.2 os&emsp;&emsp;import os 12os.listdir(dir_path) #读取获取目录下所有文件名称os.path.join(path1,path2) #拼接路径 1.3.3 torch1.3.3.1 torch.utils.data.Dataset&emsp;&emsp;from torch.utils.data import Dataset&emsp;&emsp;包含自定义数据集方法的类，用户可以通过继承该类来自定义自己的数据集类，在继承时要求用户重载__len__()和__getitem__()这两个魔法方法 1234567891011121314151617181920212223242526from torch.utils.data import Dataset from PIL import Image import os class MyData(Dataset): def __init__(self,root_dir,label_dir): self.root_dir=root_dir #根目录 self.label_dir=label_dir #标签 self.path=os.path.join(root_dir,label_dir) #图片目录 self.image_path=os.listdir(self.path) #所有图片名称 def __getitem__(self, idx): img_name=self.image_path[idx] img_idx_path=os.path.join(self.path,img_name) img=Image.open(img_idx_path) label=self.label_dir return img,label #图片信息，标签 def __len__(self): return len(self.image_path) #图片个数 root_dir=&quot;dataSet/train&quot; cat_label_dir=&quot;cat&quot; cat_dataSet=MyData(root_dir,cat_label_dir) #实例 1.3.3.2 torch.utils.data. DataLoader&emsp;&emsp;from torch.utils.data import DatLoader 1234train_loader=DataLoader(dataset=train_data,batch_size=64,shuffle=True,num_workers=0,drop_last=True)#数据集，每次打包的图片数，是否打乱，线程数，是否丢弃不够一组打包的图片#for data in train_loader# imgs,target=data #读取图片信息 1.3.3.3 torch.nn&emsp;&emsp;from torch import nn&emsp;&emsp;一个用于创建神经网络模型的类,可以作为参数、容器、子模块和函数 123456789101112131415161718192021222324252627#神经网络骨架class Name(nn.moudle): def __init__(self): super(Name,self).__init__() self.layer=layerFunc() #激活层 def forward(self,input) #前向传播 output=self.layer(input) return outputname=Name()output=name(input)name.train() #训练模式name.eval() #验证模式#卷积nn.Conv2d(in_channels=3,out_channels=6,kernel_size=3,stride=1,padding=0) #二维卷积（输入通道数，输出通道数，卷积核层数...）#池化nn.MaxPool2d(kernel_size=3,ceil_mode=True) #最大池化（核大小，步长（默认为核大小），是否填充是否舍弃不足核大小的图片部分）#非线性激活nn.sigmoid(inplace=False) #sigmoid激活（是否原地操作）#线性激活nn.Liner(input_features,output_features,bias=False) #线性激活（输入特征数，输出特征数，偏置）#序列nn.Sequential(fun1,fun2...,funN) #包装操作为序列，可读性更强#损失函数、反向传播loss=nn.CrossEntropyLoss()result_loss=loss(outputs,targets)result_loss.backword() #反向传播 将梯度记录在每层信息的weight里 1.3.3.4 torch.optim&emsp;&emsp;import torch&emsp;&emsp;用于参数优化的库（可以说是花式梯度下降） 12345optim=torch.optim.SGD(yourClass.parameters(),lr=0.01) #优化器（参数集，学习速率）#result.loss=loss(outputs,targets)#optim.zero_grad() #初始化梯度#result_loss.backword()#optim.step() 1.3.4 torchvision&emsp;&emsp;import torchvision&emsp;&emsp;处理图像的工具集 1234#获取数据集train_set=torchvision.datasets.dataname(root=&quot;./dataset&quot;,train=True,transforms=mytransform,download=True)#train_set.classes 数据集的各种类名（猫、狗...）#img,target=train_set[0] 图片信息，图片类名编号 1.3.4.1 torchvision.transforms&emsp;&emsp;from torchvision import transforms&emsp;&emsp;对图片进行操作&emsp;&emsp;使用方法： 12mytool=transforms.tool(arguments1) #实例化mytool(arguments2) #使用 &emsp;&emsp;tool: 123456789101112myToTensor=transforms.ToTensor()myImg=myToTensor(img) #将PIL或numpy.ndarry类型图片转为tensor类型并返回#tensor类型：包装了神经网络的一些参数myCompose=transforms.Compose(n)myImg=myCompose(img) #中心裁剪myNorm=transforms.Normalize([mean1...meanN],[std1...stdN]) #每个通道的均值和方差myImg=myNorm(img) #归一化myResize=transforms.Resize((h,w))myImg=myResize(img) #缩放 1.4 利用GPU加速123456#方法一if torch.cuda.is_available(): #判断GPU加速是否可用 item=item.cuda() #目标加速（可用于：imgs/targets/yourMoudle/loss）#方法二device=torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) item=item.to(device) 遇到问题：解决方案： Tips: 结语：&emsp;&emsp;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(五)—拍摄和KEYPAD照片查看","slug":"K210开发板-五-—拍摄和KEYPAD照片查看","date":"2023-09-18T16:16:58.000Z","updated":"2023-11-28T09:06:00.477Z","comments":true,"path":"2023/09/19/K210开发板-五-—拍摄和KEYPAD照片查看/","link":"","permalink":"http://example.com/2023/09/19/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%BA%94-%E2%80%94%E6%8B%8D%E6%91%84%E5%92%8CKEYPAD%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为实现拍摄和照片查看功能，摄像头实时将画面传到LCD上，按下BOOT拍照记录当前照片，按下KEYPAD进入照片查看，左滚KEYPAD查看上一张照片，右滚KEYPAD查看下一张照片，再次按下KEYPAD退出照片查看，重新恢复摄像功能。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.函数介绍1.1 lcd_draw_picture&emsp;&emsp;设置GPIO中断触发模式 参数成员 描述 输入输出 x 起始坐标 输入 y 起始坐标 输入 width 图像宽度 输入 height 图像长度 输入 *ptr 图像数据存放地址 输入 二.实验步骤1.配置&emsp;&emsp;过多了，这里就不贴了，见参考资料摄像头显示实验、按键中断实验、keypad控制RGB灯实验 2.初始化见参考文件就行，注意引脚定义不要冲突了 3.主体3.1 中断回调函数3.1.1 boot中断函数&emsp;&emsp;下降沿触发，每次按下boot时触发中断，申请一片320*240的空间，存放照片数据，最后保存地址 12345678910111213141516171819202122232425262728//button中断函数/*uint32_t phoNum=0;uint32_t g_count=-1;uint32_t *keyptrs[5]=&#123;NULL,NULL,NULL,NULL,NULL&#125;;uint32_t keyptr_addrs[5]=&#123;&#125;;*/int key_irq_cb(void* ctx)&#123; phoNum++; //照片数量 uint32_t *tmp = (uint32_t *)(ctx); //button使用次数 (*tmp)++; if(*tmp&lt;5)&#123; //存五张照片 uint32_t * keyptr=keyptrs[phoNum-1]; keyptr=(uint32_t*)iomem_malloc(CAM_WIDTH_PIXEL * CAM_HIGHT_PIXEL * 2); uint32_t *display_buf=display_buf_addr; for(int i=0;i&lt;76800;i++)&#123; *(keyptr+i)=*(display_buf+i); //写入数据 &#125; uint32_t keyptr_addr=keyptr; keyptr_addrs[phoNum-1]=keyptr_addr; //存放照片地址 lcd_draw_picture(0, 0, 320, 240,keyptr_addr); //拍摄显示 sleep(1); &#125;else&#123; printf(&quot;Photo space is full\\n&quot;); &#125; return 0;&#125; 3.1.1 boot中断函数&emsp;&emsp;下降沿触发，每次按下boot时触发中断，申请一片320*240的空间，存放照片数据，最后保存地址&#x2F;&#x2F;keypad中断函数 3.1.2 keypad中断函数&emsp;&emsp;分为左滚动中断、右滚动中断、中键中断 1234567/*uint32_t keypad_idx=1; //当前照片索引//是否处于中断标志uint32_t keypad_left_icf_flag=0;uint32_t keypad_middle_icf_flag=0;uint32_t keypad_right_icf_flag=0;*/ 3.1.2.1 左滚动中断&emsp;&emsp;用互斥锁防止由于抖动而导致相同中断同时发生好几起，当向左滚动时keypad_idx减一 12345678910111213141516171819202122232425262728int keypad_left_icf(void* ctx)&#123; msleep(10); //消抖 keypad_left_icf_flag++; //使用中断 if(keypad_left_icf_flag&gt;1)&#123; //退出其它中断 keypad_left_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_left = gpiohs_get_pin(KEYPAD_LEFT_GPIONUM); if(state_keypad_left!=0)&#123; keypad_left_icf_flag=0; return 0; &#125;; //检查 if(keypad_left_icf_flag&gt;1)&#123; keypad_left_icf_flag--; return 0; &#125; uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;Enter keypad left interrupt%d\\n&quot;,keypad_left_icf_flag); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else if((*tmp)==1)&#123; printf(&quot;This is currently the first photo, there are no more previous photos available\\n&quot;); &#125;else&#123; (*tmp)--; &#125; keypad_left_icf_flag=0; //释放中断 return 0;&#125; 3.1.2.2 左滚动中断&emsp;&emsp;用互斥锁防止由于抖动而导致相同中断同时发生好几起，当向左滚动时keypad_idx加一 123456789101112131415161718192021222324int keypad_right_icf(void* ctx)&#123; msleep(10); keypad_right_icf_flag++; //使用中断 if(keypad_right_icf_flag&gt;1)&#123; //退出其它中断 keypad_right_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_right = gpiohs_get_pin(KEYPAD_RIGHT_GPIONUM); if(state_keypad_right!=0)&#123; keypad_right_icf_flag=0; return 0; &#125;; //检查 uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;Enter keypad right interrupt\\n&quot;); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else if((*tmp)==phoNum)&#123; printf(&quot;This is currently the last photo, there are no further photos available\\n&quot;); &#125;else&#123; (*tmp)++; &#125; keypad_right_icf_flag=0; //释放中断 return 0;&#125; 3.1.2.3 中键中断&emsp;&emsp;中键按下时，如果是第一次按下，允许进入中断，如果此时有照片，就在while循环内查看当前第keypad_idx张照片，左滚动右滚动优先级都大于中键，可以用于切换照片，boot按键优先级小于中键，需要等待再次按下中键，此时退出照片查看，可以重新使用拍照功能 123456789101112131415161718192021222324252627int keypad_middle_icf(void* ctx)&#123; msleep(10); keypad_middle_icf_flag++; if(keypad_middle_icf_flag&gt;1)&#123; keypad_middle_icf_flag--; return 0; &#125; gpio_pin_value_t state_keypad_middle = gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM); if(state_keypad_middle!=0)&#123; keypad_middle_icf_flag--; return 0; &#125;; //检查 uint32_t *tmp = (uint32_t *)(ctx); if(phoNum==0)&#123; //如果没有照片 printf(&quot;There are currently no photos available\\n&quot;); &#125;else&#123; printf(&quot;enter photo view\\n&quot;); while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)!=1); //等待此次按下结束 while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)==1)&#123; //等待下次按下离开查看照片 lcd_draw_picture(0, 0, 320, 240, keyptr_addrs[keypad_idx-1]); &#125; &#125; while(gpiohs_get_pin(KEYPAD_MIDDLE_GPIONUM)!=1); //防止离开时按下的按钮继续触发查看照片 keypad_middle_icf_flag--; printf(&quot;exit keypad_enter_mid_icf%d %d\\n&quot;,keypad_middle_icf_flag,keypad_middle_icf_exit_flag); return 0;&#125; 3.1.3 摄像头中断1234567891011121314151617static int on_dvp_irq_cb(void *ctx)&#123; //读取DVP中断状态，如果完成则刷新显示地址的数据，并清除中断标志，否则读取摄像头数据 if (dvp_get_interrupt(DVP_STS_FRAME_FINISH)) &#123; dvp_set_display_addr((uint32_t)display_buf_addr); dvp_clear_interrupt(DVP_STS_FRAME_FINISH); g_dvp_finish_flag = 1; &#125; else &#123; if (g_dvp_finish_flag == 0) dvp_start_convert(); dvp_clear_interrupt(DVP_STS_FRAME_START); &#125; return 0;&#125; 3.2 while循环1234while (g_dvp_finish_flag == 0);g_dvp_finish_flag = 0;//显示画面lcd_draw_picture(0, 0, 320, 240, display_buf_addr); 三.实验总结遇到问题： KEYPAD相同中断函数同时触发两次，尽管用了互斥变量还是没能解决 LCD显示已经拍摄的照片时（除最后一张），显示花纹图像，未正确显示 LCD显示偶尔会黑屏、失真 终端中文乱码，打印出问题 KEYPAD中键检测不灵敏，需要按一小段时间才能检测到 解决方案： 未解决 未解决，估计和内存存放地址有关 Reset可解决，但原因未找明，仍会复发 改用英文，每行加回车 未解决 Tips:引脚过多，注意软件引脚定义，不要冲突 结语：&emsp;&emsp;第一次功能比较多的复合实验，遇到的冲突不少，需要注意不同功能间的交互、变量统一、冲突问题","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(四)—按键独立中断","slug":"K210开发板-四-—按键独立中断","date":"2023-09-17T10:20:11.000Z","updated":"2023-11-28T09:06:00.476Z","comments":true,"path":"2023/09/17/K210开发板-四-—按键独立中断/","link":"","permalink":"http://example.com/2023/09/17/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E5%9B%9B-%E2%80%94%E6%8C%89%E9%94%AE%E7%8B%AC%E7%AB%8B%E4%B8%AD%E6%96%AD/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为按键独立中断，按键未按下时播放音乐，按键按下时暂停播放。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.外部中断&emsp;&emsp;普通的按键的实验，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断的在实际项目的应用非常普遍。 2.按键原理&emsp;&emsp;BOOT 按键按下的时候会把电平拉低，松开的时候会把电平拉高，只需要检测 BOOT 按键的 IO 口的电平，如果是按下则会产生下降沿，松开会产生上升沿，以 此的方式来检测并触发系统的中断 3.函数介绍4.1 gpiohs_set_pin_edge&emsp;&emsp;设置GPIO中断触发模式 参数成员 描述 输入输出 pin GPIO管脚 输入 edge 中断触发方式 输入 4.2 gpiohs_irq_register&emsp;&emsp;设置GPIO中断回调函数 参数成员 描述 输入输出 pin GPIO管脚 输入 priority 中断优先级 输入 plic_irq_callback_t 中断回调函数 输入 *ctx 回调函数的形参 输入 二.实验步骤1.配置1.1 引脚12345678910111213141516171819202122//定义硬件引脚(见原理图)#define PIN_SPK_WS (30)#define PIN_SPK_DATA (31)#define PIN_SPK_BCK (32)#define PIN_KEY (16)//定义软件GPIO口#define KEY_GPIONUM (3)//将硬件引脚映射到软件GPIO功能#define FUNC_SPK_WS FUNC_I2S2_WS#define FUNC_SPK_DATA FUNC_I2S2_OUT_D0#define FUNC_SPK_BCK FUNC_I2S2_SCLK#define FUNC_KEY (FUNC_GPIOHS0 + KEY_GPIONUM)void hardware_init(void)&#123; fpioa_set_function(PIN_SPK_WS, FUNC_SPK_WS); fpioa_set_function(PIN_SPK_DATA, FUNC_SPK_DATA); fpioa_set_function(PIN_SPK_BCK, FUNC_SPK_BCK); fpioa_set_function(PIN_KEY, FUNC_KEY);&#125; 1.2 函数12345678int key_irq_cb(void* ctx)&#123; gpio_pin_value_t key_state = gpiohs_get_pin(KEY_GPIONUM); //这里只是为了测试才在中断回调打印数据，正常情况下是不建议这么做的 printf(&quot;IRQ The PIN is %d\\n&quot;, key_state); uint32_t *tmp = (uint32_t *)(ctx); printf(&quot;count is %d\\n&quot;, (*tmp)++); return 0;&#125; 2.初始化123456789101112131415161718192021222324252627// 硬件引脚初始化hardware_init();//外部中断初始化plic_init();///使能全局中断sysctl_enable_irq();//设置系统时钟sysctl_pll_set_freq(SYSCTL_PLL0, 320000000UL);sysctl_pll_set_freq(SYSCTL_PLL1, 160000000UL);sysctl_pll_set_freq(SYSCTL_PLL2, 45158400UL);uarths_init();//初始化I2Si2s_init(I2S_DEVICE_2, I2S_TRANSMITTER, 0x03);i2s_tx_channel_config( I2S_DEVICE_2, // I2S设备号 I2S_CHANNEL_0, // I2S通道 RESOLUTION_16_BIT, // 接收数据位数 SCLK_CYCLES_32, // 单个数据时钟数 TRIGGER_LEVEL_4, // DMA触发时FIFO深度 RIGHT_JUSTIFYING_MODE); // 工作模式// 初始化按键key//设置按键的GPIO模式为上拉输入gpiohs_set_drive_mode(KEY_GPIONUM,GPIO_DM_INPUT_PULL_UP);//设置按键的GPIO电平触发模式为下降沿触发gpiohs_set_pin_edge(KEY_GPIONUM,GPIO_PE_RISING);//设置按键GPIO口的中断回调gpiohs_irq_register(KEY_GPIONUM,1,key_irq_cb,&amp;g_count); 3.主体123456789101112gpio_pin_value_t key_state = gpiohs_get_pin(KEY_GPIONUM);//检测按键是否未被按下if(key_state==1)&#123; i2s_play( I2S_DEVICE_2, // I2S设备号 DMAC_CHANNEL0, // DMA通道号 (uint8_t *)test_pcm, // 播放的PCM数据 sizeof(test_pcm), // PCM数据的长度 1024, // 单次发送数量 16, // 单次采样位宽 2); // 声道数 &#125; 三.实验总结遇到问题：音乐暂停没有实现真正意义上的暂停，松开按键只会重新播放解决方案：未解决，需要了解如何暂停I2S的传输然后恢复 结语：&emsp;&emsp;无","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(三)—扬声器播放","slug":"K210开发板-三-—扬声器播放","date":"2023-09-16T14:59:34.000Z","updated":"2023-11-28T09:06:00.476Z","comments":true,"path":"2023/09/16/K210开发板-三-—扬声器播放/","link":"","permalink":"http://example.com/2023/09/16/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%B8%89-%E2%80%94%E6%89%AC%E5%A3%B0%E5%99%A8%E6%92%AD%E6%94%BE/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为扬声器的播放。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.音频转化过程&emsp;&emsp;模拟量转成数字量过程，一般可以分为三个过程，分别为采样、量化、编码， 用一个比源声音频率高的采样信号去量化源声音，记录每个采样点的值， 最后如果把所有采样点数值连接起来与源声音曲线是互相吻合的，只是它不是连续的。 在图中两条蓝色虚线距离就是采样信号的周期，即对应一个采样频率(FS)， 可以想象得到采样频率越高最后得到的结果就与源声音越吻合，但此时采样数据量越越大， 一般使用44.1KHz采样频率即可得到高保真的声音。每条蓝色虚线长度决定着该时刻源声音的量化值， 该量化值有另外一个概念与之挂钩，就是量化位数。量化位数表示每个采样点用多少位表示数据范围， 常用有16bit、24bit或32bit，位数越高最后还原得到的音质越好，数据量也会越大。 2.I2SI2S 有 3 个主要信号： 串行时钟 SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK 都有 1 个脉冲。SCLK 的频率&#x3D;2×采样频率×采样位数 帧时钟 LRCK，用于切换左右声道的数据。LRCK 为“1”表示正在传输的 是左声道的数据，为“0”则表示正在传输的是右声道的数据。LRCK 的频率等于 采样频率。 串行数据 SDATA，就是用二进制补码表示的音频数据。 &emsp;&emsp;DAC 芯片将 I2S 信号转化成 RCH 信号输送给功放，功放将 RCH 信号发大，然 后扬声器播放出对应的声音。 3.PCM&emsp;&emsp;将每个数字化声音数据转换成二进制数据，该数据就是 PCM 数据。PCM 数据可以直接存储在介质上，也可以在经过编解码处理后进行存储或传输。 &emsp;&emsp;PCM 数据常用量化指标：采样率位深、声道数、采样数据是否有符号(有符号的采样数据不能使用无符号的方式播放)、字节序（表示 PCM 数据是用大端存储还是小端存储,通常是小端存储） &emsp;&emsp;对于 8-bit PCM 数据而言，存储结构可能是左声道数据右声道数据交替存储 &emsp;&emsp;PCM数据的音量调整由于数据溢出的可能性，不应当直接将数据*n，可通过对数变换处理x * tan(x&#x2F;n)达到调整音量的效果 4.函数介绍4.1 i2s_tx_channel_config&emsp;&emsp;设置I2S发送数据的通道参数 参数成员 描述 输入输出 device_num I2S号 输入 channel_num 通道号 输入 word_length 接收数据位数 输出 word_select_size 单个数据时钟数 输入 trigger_level DMA触发时FIFO深度 输入 word_mode 工作模式 输入 4.2 i2s_play&emsp;&emsp;发送 PCM 数据, 比如播放音乐 参数成员 描述 输入输出 device_num I2S号 输入 channel_num 通道号 输入 buf PCM PCM数据 输入 buf_len PCM数据长度 输入 frame 单次发送数量 输入 bits_per_sample 单次采样位宽 输入 track_num 声道数 输入 二.实验步骤1.配置1.1.头文件12//部分头文件#include &quot;pcm.h&quot; 头文件pcm.h包含了变量uint16_t test_pcm[]，其记录了要播放音频的PCM数据，参考资料直接给出了数据。这里我通过matlab将.wav文件转为PCM数据的方式实现播放任意音频。 12345678910%读取.wav文件filename=&#x27;name.wav&#x27;;[data,fs]=audioread(filename);data=data(:,2);%将数据归一化并转换为int16类型pcm_data=int16(data * (2^15 - 1));%将int16数据转换为uint16类型pcm_data=typecast(pcm_data, &#x27;uint16&#x27;);%将数据写入文件 以逗号分隔dlmwrite(&#x27;data.txt&#x27;,pcm_data,&#x27;delimiter&#x27;,&#x27;,&#x27;); Tips:由于C语言不支持数组元素用空格分开，所以数据需要用逗号分隔再复制到pcm.h中 1.2.引脚配置123456789101112131415161718//定义硬件引脚(见原理图)#define PIN_SPK_WS (30)#define PIN_SPK_DATA (31)#define PIN_SPK_BCK (32)//定义软件GPIO口/*FUNC_I2S2_WSFUNC_I2S2_OUT_D0FUNC_I2S2_SCLK*///将硬件引脚映射到软件GPIO功能#define FUNC_SPK_WS FUNC_I2S2_WS#define FUNC_SPK_DATA FUNC_I2S2_OUT_D0#define FUNC_SPK_BCK FUNC_I2S2_SCLKvoid hardware_init(void)&#123; fpioa_set_function(PIN_SPK_WS, FUNC_SPK_WS); fpioa_set_function(PIN_SPK_DATA, FUNC_SPK_DATA); fpioa_set_function(PIN_SPK_BCK, FUNC_SPK_BCK);&#125; 2.初始化1234567891011121314151617//硬件引脚初始化hardware_init();//设置系统时钟sysctl_pll_set_freq(SYSCTL_PLL0, 320000000UL);sysctl_pll_set_freq(SYSCTL_PLL1, 160000000UL);sysctl_pll_set_freq(SYSCTL_PLL2, 45158400UL);uarths_init();//初始化I2S，第三个参数为设置通道掩码，通道0:0x03,通道1：0x0C,通道2：0x30,通道3:0xC0i2s_init(I2S_DEVICE_2, I2S_TRANSMITTER, 0x03);//设置I2S发送数据的通道参数i2s_tx_channel_config( I2S_DEVICE_2, // I2S设备号 I2S_CHANNEL_0, // I2S通道 RESOLUTION_16_BIT, // 接收数据位数 SCLK_CYCLES_32, // 单个数据时钟数 TRIGGER_LEVEL_4, // DMA触发时FIFO深度 RIGHT_JUSTIFYING_MODE); // 工作模式 3.主体12345678i2s_play( I2S_DEVICE_2, //I2S设备号 DMAC_CHANNEL0, //DMA通道号 (uint8_t *)test_pcm, //播放的PCM数据 sizeof(test_pcm), //PCM数据的长度 1024, //单次发送数量 16, //单次采样位宽 2); //声道数 三.实验总结遇到问题：PCM数据的获取解决方案：见二.1.1 结语：&emsp;&emsp;仅仅按照参考资料的程序实验是不够的，需要自己理解代码的含义，做出可拓展的尝试","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(二)—点亮LED灯","slug":"K210开发板-二-—点亮LED灯","date":"2023-09-16T05:40:42.000Z","updated":"2023-11-28T09:06:00.467Z","comments":true,"path":"2023/09/16/K210开发板-二-—点亮LED灯/","link":"","permalink":"http://example.com/2023/09/16/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%BA%8C-%E2%80%94%E7%82%B9%E4%BA%AELED%E7%81%AF/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为LED灯的交替闪烁。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.实验准备1.GPIO&emsp;&emsp;我个人理解是将芯片的的操作封装成函数，使微控制器成为微处理器 好比你告诉家里的保姆说“去吧客厅的灯关上”，他就走过去按动灯的开关，然后灯就灭了。你下的这个指令的动作相当于调用了GPIO操作的函数，保姆去按开关这个动作相当于函数配置寄存器。 2.K210的GPIO—FPIOA&emsp;&emsp;FPIOA （现场可编程 IO 阵列）允许用户将 255 个内部功能映射到芯片外围的 48 个自由 IO 上 二.实验步骤1.配置1234567891011121314//定义硬件引脚(见原理图)#define PIN_LED_0 (0)#define PIN_LED_1 (17)//定义软件GPIO口#define LED0_GPIONUM (0)#define LED1_GPIONUM (1)//将硬件引脚映射到软件GPIO功能#define FUNC_LED0 (FUNC_GPIO0 + LED0_GPIONUM)#define FUNC_LED1 (FUNC_GPIO0 + LED1_GPIONUM)void hardware_init(void)&#123; fpioa_set_function(PIN_LED_0, FUNC_LED0); fpioa_set_function(PIN_LED_1, FUNC_LED1);&#125; 2.初始化123456789hardware_init(); //硬件引脚初始化gpio_init(); // 使能GPIO的时钟// 设置LED0和LED1的GPIO模式为输出gpio_set_drive_mode(LED0_GPIONUM, GPIO_DM_OUTPUT);gpio_set_drive_mode(LED1_GPIONUM, GPIO_DM_OUTPUT);// 先关闭LED0和LED1gpio_pin_value_t value = GPIO_PV_HIGH;gpio_set_pin(LED0_GPIONUM, value);gpio_set_pin(LED1_GPIONUM, value); 3.主体123sleep(1); //延时1sgpio_set_pin(LED0_GPIONUM, value); //设置引脚值gpio_set_pin(LED1_GPIONUM, value = !value); 三.实验总结遇到问题：未能理解FUNC_GPIO0的作用解决方案：暂未解决 结语：&emsp;&emsp;无","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(一)—搭建开发环境","slug":"K210开发板-一-—搭建开发环境","date":"2023-09-15T13:53:59.000Z","updated":"2023-11-28T09:06:00.467Z","comments":true,"path":"2023/09/15/K210开发板-一-—搭建开发环境/","link":"","permalink":"http://example.com/2023/09/15/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E4%B8%80-%E2%80%94%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录K210的学习和自己遇到的问题，主要内容为开发环境的搭建。由于参考资料的教程比较齐全，本文会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 一.安装串口驱动&emsp;&emsp;使用参考资料中的程序安装即可 遇到问题：设备管理器中找不到端口选项解决方案：点击 查看-&gt;显示隐藏的设备即可 Tips:连接开发板需要用数据线，连接仅能充电的线电脑是没有反应的 二.配置VSCode开发环境&emsp;&emsp;按照参考资料中的教程即可 创建新项目 把项目文件(包含main.c)复制到 SDK 中的src目录下 进入 build 目录，运行命令 cmake .. -DPROJ&#x3D;name -G “MinGW Makefiles” make 打开kfalsh把生成的.bin文件(填入路径)烧录到开发板上 遇到问题：解压参考资料里的toolchain时报错：路径太长无法复制解决方案：进入https://www.canaan-creative.com/developer 下载压缩包即可 结语：&emsp;&emsp;搭建过程友好，不要气馁","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"K210开发板(零)","slug":"K210开发板-零","date":"2023-09-15T10:44:02.000Z","updated":"2023-11-28T09:06:00.483Z","comments":true,"path":"2023/09/15/K210开发板-零/","link":"","permalink":"http://example.com/2023/09/15/K210%E5%BC%80%E5%8F%91%E6%9D%BF-%E9%9B%B6/","excerpt":"","text":"一.介绍&emsp;&emsp;本类博客categories:嵌入式-&gt;K210 tags:K210&emsp;&emsp;本类博客用于记录自己的K210开发板学习过程，由于参考资料的教程比较齐全，本类博客会着重于讲述自己遇到的问题和解决方案 参考资料:http://www.yahboom.com/study/K210-Developer-Kit提取码：moj1 二.本类博客风格 第一篇为开发环境的搭建，之后为记录程序实践，第一篇不适用于下述风格 二级标题必选为实验准备、实验步骤、实验总结 实验步骤中三级标题可选为代码编写、烧录结果 代码编写中四级标题可选为&emsp;&emsp;配置（main函数前部分）&emsp;&emsp;初始化（main函数至while循环部分&emsp;&emsp;主体（while循环中和中断回调函数中部分）&emsp;&emsp;其它（while循环后部分） 配置中五级标题可选为头文件、引脚、函数 主题中五级标题可选为while循环和中断回调函数","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"}],"tags":[{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2023-09-15T07:44:02.000Z","updated":"2023-09-16T13:27:42.216Z","comments":true,"path":"2023/09/15/我的第一篇博客/","link":"","permalink":"http://example.com/2023/09/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"简介：&emsp;&emsp;本篇博客用于记录自己的第一篇博客，主要内容为Hexo的主要指令和markdown的主要语法 一.Hexo主要指令 hexo -n “xxx” %创建一个新文章 hexo clean %清理 hexo -g %生成 hexo -s %预览 hexo -d %部署 %http://localhost:4000/ #本地访问地址%https://arrowonstr.github.io/ #查看博客 二.markdown主要语法 %n级标题 #*n %引用 &gt; %列表 - %代码块 &#96;&#96;&#96;代码语言 %脚注 [^] %横线 — %网址 [网站]（地址”注释”) %超链接 [标题](#标题） %图片 ！[图片](链接”注释”） %斜体 ** %加粗 ** ** %行内代码&#x2F;使符号不起格式作用 `` %下划线 &lt;u&gt;下划线&lt;/u&gt; %高亮 &#x3D;&#x3D; &#x3D;&#x3D; 结语：&emsp;&emsp;博客之旅由此开始","categories":[{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"我是即将到来的日子","slug":"我是即将到来的日子","date":"2023-09-15T07:00:00.000Z","updated":"2023-09-17T15:54:30.715Z","comments":true,"path":"2023/09/15/我是即将到来的日子/","link":"","permalink":"http://example.com/2023/09/15/%E6%88%91%E6%98%AF%E5%8D%B3%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%A5%E5%AD%90/","excerpt":"","text":"我的博客风格%日记类的博客可以不按照任意风格格式 1.博客框架 每篇博客使用tags归类 类内博客标题使用xxx(一)—xxx的格式 类内博客第一篇标题为xxx(零)，内容为：&emsp;&emsp;该类博客的主要介绍&emsp;&emsp;该类博客的风格 类内博客简介包含该类的主要介绍 类内博客最后一篇标题为xxx(END) tags包含”日记” 2.行文框架 行文第一块为简介：xxx 字体为灰色 行文第二块为参考资料 正文从二级标题开始 %一级标题为文章标题&emsp;&emsp;二级标题使用 一. 二. 三. …&emsp;&emsp;三级标题使用 1. 2. 3. …&emsp;&emsp;四级标题使用 1.1. 1.2. 1.3.&emsp;&emsp;以此类推… 建议在内容下添加&emsp;&emsp;遇到问题&amp;解决方案 颜色为#3399ff&emsp;&emsp;Tips 颜色为#ff6600 行文结尾为结语：xxx 颜色为灰色 3.其它 正文注释使用% 代码注释依据语言决定 &emsp;&emsp;早祷的钟声突然响了，无数的钟声一下子都惊醒了。天又黎明！黑沉沉的危崖后面，看不见的太阳在金色的天空升起。快要倒下来的克利斯朵夫终于到了彼岸。于是他对孩子说： &emsp;&emsp;“咱们到了！唉，你多重啊！孩子，你究竟是谁呢？” &emsp;&emsp;孩子回答说： &emsp;&emsp;“我是即将来到的日子。” ***","categories":[{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"编译原理","slug":"笔记/编译原理","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"人工智能","slug":"笔记/人工智能","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"yolo","slug":"笔记/人工智能/yolo","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/yolo/"},{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"程序设计","slug":"项目/程序设计","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"会议室系统","slug":"项目/程序设计/会议室系统","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%B3%BB%E7%BB%9F/"},{"name":"嵌入式","slug":"项目/嵌入式","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"K210","slug":"项目/嵌入式/K210","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E5%B5%8C%E5%85%A5%E5%BC%8F/K210/"},{"name":"日记","slug":"日记","permalink":"http://example.com/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"qt","slug":"qt","permalink":"http://example.com/tags/qt/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"},{"name":"K210","slug":"K210","permalink":"http://example.com/tags/K210/"},{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]}